% !!! xdsuser -> xcwork xcsamp

\chapter{Первые шаги}\label{start}

В этой и последующих главах мы предполагаем, что
пакет \xds{} уже успешно инсталлирован и настроен
(см. Часть \ref{config}); и что используются расширения файлов,
заданные по умолчанию.

В пакете \XDS{} есть файл \XC{}{\tt work} со скриптом
для создания рабочей директории.
Более подробно об этом --- в файле {\tt readme.1st}
из встроенной документации к \XDS{}.

\section{Работа с компилятором с Модулы-2}

Используя любой редактор текстов, создайте в рабочей директории
файл {\bf hello.mod}, содержащий следующий текст:

\begin{verbatim}
MODULE hello;

IMPORT InOut;

BEGIN
 InOut.WriteString("Hello World");
 InOut.WriteLn;
END hello.
\end{verbatim}

Теперь наберите:
\begin{flushleft} \tt
        \XC{} hello.mod
\end{flushleft}
\xc{} запустит компилятор  \mt{}, поскольку исходный файл имеет 
расширение {\bf.mod}. На экране появится заголовок:
\begin{verbatim}
Modula-2 версия [генератор кода] "hello.mod"
\end{verbatim}
показывающий, какой вызван компилятор (включая его номер версии),
затем, в квадратных скобках, --- какой генератор кода используется 
и какой номер его версии, и наконец --- имя исходного файла, посланного на 
компиляцию.

Если Вы правильно набрали текст файла, то после компиляции
на экране появится строка
\begin{verbatim}
errors: 0(0)  lines: 15  time: 1.09
\end{verbatim}
показывающая количество ошибок, количество строк исходного текста
и время, ушедшее на компиляцию.

{\bf Замечание:} Сообщения компилятора \XDS{} также модифицируемы
пользователем. Если строчки, указанные выше, не появились, проверьте,
содержит ли значение параметра \OERef{DECOR}
буквы `c' (заголовок компилятора) и `r' (сообщение).

\section{Работа с компилятором с Оберона-2}

В нашей двуязычной системе приведенный выше
исходный текст на языке \mt{} является в то же время правильным текстом
на языке \ot{}. \xds{} позволяет использовать 
\mt{} -- библиотеки, программируя на языке \ot{} (в нашем случае
это библиотека {\tt InOut}).

Как и в Модуле-2, на Обероне-2 этот текст представляет собой
{\em модуль верхнего уровня}, или {\em программный модуль}.
Но, в отличие от Модулы-2, в Обероне-2 нет никаких синтаксических различий
между головным и любым другим модулем. 
Требуется сообщить компилятору с Оберона-2, что данный модуль
--- программный, выставив опцию \OERef{MAIN}.
Скопируйте исходный файл в файл {\bf hello.ob2} и наберите:
\begin{flushleft} \tt
        \XC{} hello.ob2 +MAIN
\end{flushleft}
Появится та же последовательность сообщений, что и раньше, но
вдобавок Оберон-2 компилятор сообщит, сгенерирован ли новый 
символьный файл.

Расширение в имени исходного файла перекрывается опциями
\OERef{M2} и \OERef{O2}:
\begin{flushleft} \tt
        \XC{} hello.mod +O2 +MAIN
\end{flushleft}
В этом случае будет вызван компилятор с Оберона-2, несмотря на
расширение имени файла.

\section{Сообщения об ошибках}

Когда компилятор находит ошибку, на экран выводится описание 
этой ошибки. В большинстве случаев при этом также выводится строка
исходного текста со знаком \verb|"$"|, помещенным прямо перед точкой, 
в которой обнаружена ошибка.
Пользователь может менять формат сообщений \xds{} об ошибках
(см. \ref{opt:errfmt}); по умолчанию сообщение содержит
имя файла, номер строки и позиции в строке, в которой обнаружена
ошибка, и тип ошибки.
Ошибки могут быть трех типов: [E]rror, [W]arning or [F]ault
(Ошибка, Предупреждение и Фатальная ошибка).

\Example
\begin{verbatim}
(hello.m 6,33) [E] ожидался символ  ")"
 InOut.WriteString("Hello World"$;
(hello.m 7,2) [E] ожидался символ  ";"
 $InOut.WriteLn;
\end{verbatim}

\section{Запуск программы}\label{start:run}
\index{запуск программы}

\ifgencode        %----------------------

Чтобы автоматически слинковать программу, надо запустить
компилятор в режиме MAKE: % !!! ref

\verb'    xc =m hello.mod'

В этом режиме компилятор обрабатывает все модули, импортируемые
указанным в командной строке, при необходимости их компилируя.
Затем, если указанный модуль является головным, то запускается линкер.

Однако, если Ваша программа состоит из нескольких модулей, мы рекомендуем
создать для нее проектный файл
(см. \ref{xc:project}) и использовать подходящий файл-шаблон
(см. \ref{xc:template}).

Пример проектного файла, содержащего установку всех необходимых
параметров:
\begin{verbatim}
% debug ON
-gendebug+
-genhistory+
-lineno+
% указать файл-шаблон
-template = xc.tem
% имя файла заданий линкеру
-mkfname = tmp
-mkfext  = rsp
% включить генерацию файла заданий
-makefile+
% командная строка линкера
-link = "xlink @%s",mkfname#mkfext;
% головной модуль
!module hello.mod
\end{verbatim}
Он задает, какой файл-шаблон использовать
({\tt xc.tem}), в какой файл записать задание линкеру
({\tt tmp.rsp}) и командную строку для линкера.

После успешной компиляции всего проекта компилятор создаст файл
заданий линкеру и затем исполнит командную строку, заданную
параметром \OERef{LINK}.

Файл-шаблон {\tt xds.tem} задает образец для файла заданий линкеру.
\ifcomment
\begin{verbatim}
/sys=C
!if gendebug then
  /debug
!end
!if defined stacklimit then
  ! "/stack=%s\n",stacklimit;
!else
  /stack=128K
!end
! { main : "/name=%s\n",#>exeext; }
! { main imp oberon : "%s\n",#>objext }
! "%s\n","libxds"#"lib"
\end{verbatim}

Итератор
\begin{verbatim}
{ main imp oberon : "%s\n",#>objext }
\end{verbatim}
вставит имена объектных файлов всех модулей, образующих Вашу программу.

Вызов 
\begin{flushleft} \tt
        \xc{} hello.prj =p
\end{flushleft}
приведет к компиляции (если необходимо) всех модулей проекта и 
последующему запуску линкера.
\fi
Подробное описание файлов-шаблонов см. в \ref{xc:template}.
Ознакомьтесь также с проектными файлами, сгенерированными скриптом
{\tt xdsuser}.

\fi % end ifgencode ----------------------

\ifgenc %----------------------

 После компиляции программы {\tt hello} Вы можете вызывать 
 C компилятор.
 \index{C компилятор}
 Необходимо указать пути к файлам-заголовкам и к библиотекам
 (используйте подходящую библиотеку из Вашего пакета).
 Синтаксис командной строки вашего C-компилятора описан в руководстве
 к нему.
 \begin{verbatim}
   cc hello.c -Ic:\xds\include c:\xds\lib\libxds.lib
 \end{verbatim}
 Наберите
 \begin{verbatim}
   hello
 \end{verbatim}
 чтобы запустить программу.

 Скрипт {\tt xdsuser} создает файл {\tt xcc} со скриптом, который
 можно использовать для компиляции и сборки простых программ.
 Наберите
 \begin{verbatim}
   xcc hello.c
 \end{verbatim}
Если Ваш проект состоит из нескольких модулей, мы рекомендуем 
написать для него проектный файл
(см. \ref{xc:project}), воспользовавшись подходящим файлом-шаблоном
(см. \ref{xc:template}).
Пример проектного файла, устанавливающего все необходимые параметры:
\begin{verbatim}
% debug ON
-gendebug+
-lineno+
% задать файл-образец
-template = xds.tem
% задать имя make-файла
-mkfname = tmp
-mkfext  = mkf
% включить генерацию make-файла
-makefile+
% вызов сборщика
-link = "make -f %s",mkfname#mkfext;
% головной модуль программы
!module hello.mod
\end{verbatim}
Он задает имя нужного файла-образца ({\tt xds.tem}), 
имя make-файла ({\tt tmp.mkf}) 
и командную строку для сборщика.

После успешной компиляции всего проекта компилятор создает
make-файл и затем исполняет командную строку, заданную параметром
{\bf LINK}.
Файл-шаблон {\tt xds.tem} определяет заготовку для make-файла.
Вызов
\begin{flushleft} \tt
        \xc{} hello.prj =p
\end{flushleft}
приведет к компиляции (если необходимо) всех модулей проекта и 
последующему запуску сборщика.
Полное описание файлов-шаблонов содержится в \ref{xc:template}.
Ознакомьтесь также с проектными файлами, сгенерированными скриптом
{\tt xdsuser}.

\fi %----------------------

\section{Отладка программы}\label{start:debug}
\index{отладка программы}

\ifgencode

Компиляторы \XDS{} генерируют отладочную информацию в формате
\iflinux stabs \else CodeView \fi и позволяют использовать любой 
отладчик, совместимый с этим форматом
\iflinux (например GDB)\fi.  
Однако во многих случаях вместо отладчика достаточно использовать
{\em посмертную историю}\index{history}\index{посмертная история},
--- средство, предоставляемое в числе средств поддержки исполнения 
в пакете \XDS{}.
Для этого опция \OERef{LINENO} должна быть выставлена для всех модулей
программы, а опция \OERef{GENHISTORY} --- для головного модуля;
\ifosii
линкер (link386) должен вызываться с опцией  \verb'/debug'.
\fi
\ifwinnt
линкер (xlink) должен вызываться с опцией  \verb'/debug'.
\fi

Если программа скомпилирована в таком режиме, то при ее аварийном
завершении система поддержки исполнения распечатает стек процедурных
вызовов (имя файла и номер строки исходного текста).

\Example
\begin{verbatim}
MODULE test;

PROCEDURE Div(a,b: INTEGER): INTEGER;
BEGIN
  RETURN a DIV b
END Div;

PROCEDURE Try;
  VAR res: INTEGER;
BEGIN
  res:=Div(1,0);
END Try;

BEGIN
  Try;
END test.
\end{verbatim}

\noindent
При работе этой программы возбудится исключение (exception), 
и система выдаст место, где оно возбуждено, и стек вызовов процедур.
\pagebreak[3]
\begin{verbatim}
#RTS: No exception handler #6: zero or negative divisor
------------------------------------------------------------
Source file                        LINE  OFFSET  PROCEDURE
------------------------------------------------------------
"test.mod"                            5 0000000D
"test.mod"                           11 00000024
"test.mod"                           15 00000051
\end{verbatim}
Исключение возбуждено в строке 5 файла {\tt test.mod},
процедура {\tt Div} была вызвана из строки 11,
а процедура {\tt Try} из строки 15
(в теле модуля).

{\bf Замечание} В некоторых ситуациях история может давать неверные
номера строк. Подробнее см. \ref{rts:history}.

\fi % ifgencode --------------------------

\ifgenc % debugging

\XDS{} позволяет использовать любой стандартный отладчик.
Однако во многих случаях вместо отладчика достаточно использовать
{\em посмертную историю}\index{история}\index{посмертная история},
--- средство, предоставляемое в числе средств поддержки исполнения 
в пакете \XDS{}.
Для этого опция \OERef{GENDEBUG} должна быть выставлена во всех модулях
программы, а у C-компилятора и линкера --- включен режим отладки.

Если программа скомпилирована в таком режиме, то при ненормальном ее 
завершении система поддержки исполнения распечатает стек процедурных
вызовов (имя файла и номер строки исходного текста).

\Example
\begin{verbatim}
MODULE test;

PROCEDURE Div(a,b: INTEGER): INTEGER;
BEGIN
  RETURN a DIV b
END Div;

PROCEDURE Try;
  VAR res: INTEGER;
BEGIN
  res:=Div(1,0);
END Try;

BEGIN
  Try;
END test.
\end{verbatim}
При работе этой программы возбудится исключение (exception), 
и система выдаст место, где оно возбуждено, и стек вызовов процедур.
Если выставлена опция \OERef{LINENO}, то вся информация будет выдана
в терминах исходных (\ot{}/\mt{}) файлов:
\begin{verbatim}
#RTS: No exception handler #6: zero or negative divisor.
test.mod              5
test.mod             11
test.mod             15
\end{verbatim}
Исключение возбуждено в строке 6 файла {\tt test.mod},
процедура {\tt Div} была вызвана из строки 12,
а процедура {\tt Try} из строки 16
(в теле модуля).

Если опция \OERef{LINENO} не выставлена, вся информация будет в терминах
порожденных C-файлов:
\begin{verbatim}
#RTS: No exception handler #6: zero or negative divisor.
test.c               17
test.c               27
test.c               36
\end{verbatim}
См. более подробное описание в \ref{maptoc:opt:gen}.

\fi % end ifgenc (debugging) ----------------------

\ifgencode
\section{Оптимизация программы}\label{start:optim}
\index{оптимизация программы}

% !!! Rewrite, mention GENFRAME, and probably the IDE style sheets

В отличие от многих других компиляторов, \XDS{} 
всегда генерирует оптимизированный код. 
В \XDS{} нет таких понятий, как уровни или различные типы оптимизаций,
за исключением переупорядочения команд\footnote{введено в версии 2.14}, %???
которое можно включить или выключить опцией \OERef{DOREORDER}.
Почти с любым компилятором может случиться так, что неоптимизированная
версия программы работает нормально, а оптимизированная --- нет.
Если у компилятора десяток--полтора оптимизационных опций, то его может
оказаться очень трудно отладить. Его авторам придется проверять все
возможные комбинации этих опций.
С \XDS{} все иначе.
Единственная опция, которая неявно выключает некоторые 
оптимизации, --- это \OERef{GENDEBUG}.

Есть, тем не менее, несколько способов контролировать генерацию кода.
Во-первых, Вы должны решить, что для Вас важнее: быстрый код или 
маленький код.
По умолчанию, опция \OERef{SPACE} выключена,
что заставляет компилятор заботиться в первую очередь о быстроте кода.

Чтобы добиться максимальной производительности, сделайте следующее:
\begin{itemize}
\item выключите \OERef{SPACE}             % References for printed version
\item выключите \OERef{GENDEBUG} 
\iflinux \else % ALIGNMENT should ALWAYS be set to 4 for Linux   % !!!
\item установите параметр \OERef{ALIGNMENT} равным 4
\fi
\item включите \OERef{DOREORDER} 
\item задайте параметры \OERef{CPU} и \OERef{MINCPU}
\item выключите проверки во время исполнения и проверки на переполнение.
\end{itemize}
Впрочем, в финальной версии вашего продукта можно и не выключать
проверки во время исполнения, т.к. генератор кода обычно удаляет все 
избыточные проверки. Типичная программа исполняется лишь на 
10-15\% быстрее, если все проверки выключены (но размер кода при этом
уменьшается более значительно).

Две оптимизации следует использовать с осторожностью:
\begin{itemize}
\item опция \OERef{PROCINLINE} разрешает компилятору подставлять 
      текст некоторых процедур вместо их вызовов. Как правило, ее
      включение приводит к более быстрому, но более громоздкому коду.
      Однако, ее эффект сильно зависит от Вашего стиля программирования
      (размер процедур и~т.п.).
\item опция \OERef{NOPTRALIAS} разрешает компилятору предполагать,
      что все указатели указывают на структурные переменные
      (указатели не используются как алиасы). Включение этой опции
      улучшает качество кода.
\end{itemize}

\paragraph{Пример проектного файла для максимальной производительности}
\begin{verbatim}
-alignment=4          % is unnecessary under Linux
-noptralias+
-procinline+
-space
-doreorder+
-cpu486

-checkindex
-checkrange
-checknil
-ioverflow
-coverflow
-gendebug
-genhistory
-lineno
!module Foo.mod
\end{verbatim}
В некоторых случаях выгодно выставлять разные опции для разных
модулей программы. См. {\tt dry.mod} в примерах программ в \XDS{}.

\fi % end ifgencode ----------------------
