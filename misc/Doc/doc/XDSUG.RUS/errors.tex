\newcommand{\Message}[3]{
\ifonline
  \subsection{#1#2}
  \public{MESSAGE\_#2}{\tt #3}
\else
 {\bf #1#2}\\{\tt #3}\index{message!#1#2}
\fi}

\chapter{Сообщения компилятора}

В этой главе дается объяснение сообщениям диагностики компилятора.
Для каждой ошибки приводится ее номер, текст сообщения об ошибке и
объяснение. Текст сообщения может содержать спецификации формата
вида \verb'%d' для числа или \verb'%s' для строки. В таком случае
аргумент (или аргументы) описываются в следующей строке.

В большинстве случаев компилятор выводит строку исходного текста,
в которой найдена ошибка. Позиция ошибки в строке отмечается знаком доллара 
(\$) непосредственно перед точкой, в которой произошла ошибка.

\section{Лексические ошибки}

\Message{E}{001}{недопустимый символ}

Все символы из наборов символов языков \mt{} или \ot{} 
разрешены. Контрольные символы от
\verb'0C' до \verb'37C' игнорируются.
Остальные символы, напр. \verb|%|, незаконны.

\Message{E}{002}{незакрытый комментарий, начатый в строке \%d}
(номер строки)

Опущена закрывающая скобка \verb'"*)"' комментария, начавшегося
в указанной строке.

\Message{E}{003}{неверное число}

Эта ошибка возникает в следующих случаях:
\begin{itemize}
\item числовая константа содержит символ, не являющийся цифрой
      (\verb'0..7' для восьмеричных констант, \verb'0..9' для десятичных,
      \verb'0..9,A..F' для шестнадцатиричных).
\item в вещ. константе после знака степени не идет целое число
\item число заканчивается незаконным суффиксом, напр.
\verb'"X"' в Модуле-2
или \verb'"C"' или \verb'"B"' в Обероне-2.
\end{itemize}

\Message{E}{004}{незакрытая или слишком длинная строка}

Эта ошибка обычно возникает, когда забыта закрывающая кавычка строки,
или когда она не соответствует открывающей. Заметьте, что 
константная строка должна содержаться в одной строке текста, и
не может быть длиннее 256 символов.
Для образования более длинных константных строк в языке \mt{} можно 
использовать конкатенацию строк.

\Message{F}{005}{неожиданный конец файла}

Входной файл закончился до конца модуля.

\Message{E}{006}{слишком длинный идентификатор}

Длина идентификатора превосходит предельную (127 символов).

\Message{F}{010}{ошибка чтения исходного текста}

Ошибка чтения при чтении исходного файла.

\Message{E}{012}{слишком большая литерная константа (377C или 0FFX максимум)}

\Message{E}{171}{неверная структура команд условной компиляции}

Эта ошибка выдается, когда нарушена структура \verb'IF'-выражения 
для условной компиляции, напр. когда нет 
\verb'IF', соответствующего \verb'END', \verb'ELSE' или \verb'ELSIF';
или если нет \verb'END', соответствующего \verb'IF'.

\Message{E}{172}{опция условной компиляции начинается с неверного символа}

Ожидаются \verb'IF', \verb'ELSIF', \verb'ELSE', \verb'END', или идентификатор.

\Message{F}{173}{незакрытая прагма, начатая в строке \%d}
(номер строки)

Опущена закрывающая скобка \verb'"*>"' прагмы, начавшейся
в указанной строке.

\Message{F}{174}{конец файла во время пропуска текста; см. строку \%d}
(номер строки)

Входной файл закончился, когда компилятор пропускал часть исходного текста 
в соответствии с оператором условной компиляции. Это может быть 
результатом опущенного закрывающего 
\verb'<* END *>'. Проверьте прагму в указанной строке.

\Message{E}{175}{неверный синтаксис прагмы}

См. синтаксис прагм в настоящем руководстве.

\section{Синтаксические ошибки}

\Message{E}{007}{ожидался идентификатор}

В указанной позиции ожидался идентификатор.

\Message{E}{008}{ожидался символ \%s}
(symbol)

В указанной позиции компилятор ожидал данный символ. Символ может быть
одним из следующих:

\begin{verbatim}
        |       ;       :       .       [       ]       :=
        (       )       {       }       ,       =       ..
        DO      END     OF      THEN    TO      UNTIL   IMPORT
        MODULE
\end{verbatim}

\Message{E}{081}{ожидалось начало множителя}

Компилятор ожидал в указанной позиции начало {\bf Множителя},
т.е. идентификатор, константу, агрегат, левую скобку и~т.д.
См. синтаксис языка.

\Message{E}{082}{ожидалось начало описания}

Компилятор ожидал в указанной позиции начало описания, т.е. 
одно из ключевых слов:
\verb'"CONST"', \verb'"VAR"', \verb'"TYPE"',
\verb'"PROCEDURE"', \verb'"BEGIN"' или \verb'"END"'.

\Message{E}{083}{ожидалось начало типа}

Компилятор ожидал в указанной позиции начало типа.
См. синтаксис языка.

\Message{E}{085}{ожидалось выражение}

Компилятор ожидал в указанной позиции выражение.

\Message{E}{086}{ожидалось начало оператора}

Компилятор ожидал в указанной позиции начало оператора.
См. синтаксис языка.

\section{Семантические ошибки}

\Message{E}{020}{неописанный идентификатор "\%s"}
(имя)

Указанный идентификатор неопределен в текущем контексте.

\Message{E}{021}{имя типа "\%s" нельзя использовать в собственном описании}
(имя)

Идентификатор, объявленный как имя типа, может использоваться
в описании этого типа лишь в тех случаях, когда это --- новый тип
указателя или новый тип процедуры. Эта ошибка, например, возникает
в следующем тексте:

\begin{verbatim}
TYPE
  Rec = RECORD
    next: POINTER TO Rec;
  END;
\end{verbatim}

Следует писать:

\begin{verbatim}
TYPE
  Ptr = POINTER TO Rec;
  Rec = RECORD
    next: Ptr;
  END;
\end{verbatim}

\Message{E}{022}{идентификатор "\%s" уже описан в \%s[\%d.\%d]}
(имя,имя файла,строка,столбец)
\Message{E}{028}{идентификатор "\%s" уже описан в другом модуле}
(имя)

Описываемый идентификатор уже известен в текущем контексте
(используемое имя уже имеет какое-то значение). Если имя файла
и позиция в тексте предыдущего определения известны, то выдается
сообщение об ошибке 022, иначе 028.

\Message{E}{023}{процедура с FORWARD-описанием не может быть кодовой}

Процедура, имеющая FORWARD-описание, описывается как кодовая процедура.

\Message{E}{024}{рекурсивный импорт}

Модуль импортирует сам себя. Например:
\begin{verbatim}
MODULE xyz;

IMPORT xyz;

END xyz.
\end{verbatim}

\Message{E}{025}{экспортируемый объект не определен}

Объект, экспортируемый из локального модуля, не определен в нем.
Пример:

\begin{verbatim}
MODULE M; (* локальный модуль *)

EXPORT Foo;

END M;
\end{verbatim}


\Message{E}{026}{идентификатор "\%s" используется в своем собственном описании, см. \%s[\%d.\%d]}

Идентификатор используется в своем собственном описании, например:
\begin{verbatim}
CONST c = 1;
PROCEDURE proc;
  CONST c = c + 1;
END proc;
\end{verbatim}

\Message{E}{027}{незаконное использование имени модуля "\%s"}
(имя модуля)

Идентификатор, обозначающий модуль, не может находиться в указанной позиции.

\Message{E}{029}{несовместимые типы: "\%s" "\%s"}
(тип,тип)
\Message{E}{030}{несовместимые типы}

Компилятор сообщает об этой ошибке в следующих случаях:
\begin{itemize}
\item операнды в выражении несовместимы
\item в операторе присваивания выражение не совместимо с типом переменной
\item в вызове процедуры фактический параметр несовместим с типом
формального параметра.
\end{itemize}

Компилятор сообщает об ошибке 29, если он может назвать несовместимые
типы, и об ошибке 30, если не может.

\Message{E}{031}{идентификатор не обозначает тип}

В указанной позиции ожидался идентификатор, обозначающий тип.

\Message{E}{032}{ожидался скалярный тип}

Компилятор ожидал обозначение скалярного типа 
(вещественного, целого, перечислимого, \verb'CHAR' или \verb'BOOLEAN').

\Message{E}{033}{ожидался порядковый тип}

Компилятор ожидал значение, переменную или обозначение типа одного из
порядковых типов,  т.е.
\verb'CHAR', \verb'BOOLEAN', перечислимого, целого или натурального типа,
или диапазона одного из этих типов.

\Message{E}{034}{незаконная комбинация параметров в преобразовании типа}

Использованная комбинация параметров в вызове процедуры VAL запрещена
по определению языка.

\Message{E}{035}{NEW: "\%s" невидима в этом контексте}
(ALLOCATE или DYNALLOCATE)

Вызов процедуры \verb'NEW' заменяется на вызов процедуры
\verb'ALLOCATE' (или \verb'DYNALLOCATE' для открытых массивов).
Требуемая процедура невидима в текущем контексте. Ее
нужно импортировать или реализовать.

{\bf Замечание:} В \xds{} можно разрешить использование встроенных
процедур распределения памяти,
выставив опцию \OERef{STORAGE}.

\Message{E}{036}{DISPOSE: "\%s" невидима в этом контексте}
(DEALLOCATE или DYNDEALLOCATE)

Вызов процедуры \verb'DISPOSE' заменяется на вызов процедуры
\verb'DEALLOCATE' (или \verb'DYNDEALLOCATE' для открытых массивов).
Требуемая процедура невидима в текущем контексте. Ее
нужно импортировать или реализовать.

{\bf Замечание:} В \xds{} можно разрешить использование встроенных
процедур распределения памяти,
выставив опцию \OERef{STORAGE}.

\Message{E}{037}{процедура "\%s" не может быть функцией}
(имя процедуры)

В языке \mt{} вызовы процедур \verb'NEW' и \verb'DISPOSE' заменяются на
вызовы \verb'ALLOCATE' и \verb'DEALLOCATE'; или для динамических массивов
\verb'DYNALLOCATE' и \verb'DYNDEALLOCATE'.
Сообщение об ошибке выдается, если соответствующая процедура описана 
как функция.

\Message{E}{038}{неверное число параметров "\%s"}
(имя процедуры)

В языке \mt{} вызовы процедур \verb'NEW' и \verb'DISPOSE' заменяются на
вызовы \verb'ALLOCATE' и \verb'DEALLOCATE'; или для динамических массивов
\verb'DYNALLOCATE' и \verb'DYNDEALLOCATE'.
Сообщение об ошибке выдается, если соответствующая процедура 
имеет неверное число параметров.

\Message{E}{039}{процедура "\%s": ожидался \%s параметр "\%s"}
(имя процедуры, "VAR" или "value", имя параметра)

В языке \mt{} вызовы процедур \verb'NEW' и \verb'DISPOSE' заменяются на
вызовы \verb'ALLOCATE' и \verb'DEALLOCATE'; или для динамических массивов
\verb'DYNALLOCATE' и \verb'DYNDEALLOCATE'.
Сообщение об ошибке выдается, если в описании соответствующей процедуры
способ передачи указанного параметра (\verb'VAR' или value) неверен.

\Message{E}{040}{процедура "\%s": неверный тип параметра "\%s"}

В языке \mt{} вызовы процедур \verb'NEW' и \verb'DISPOSE' заменяются на
вызовы \verb'ALLOCATE' и \verb'DEALLOCATE'; или для динамических массивов
\verb'DYNALLOCATE' и \verb'DYNDEALLOCATE'.
Сообщение об ошибке выдается, если в описании соответствующей процедуры
тип указанного параметра неверен.

\Message{E}{041}{проверяемый или охраняемый тип не есть расширение типа переменной}

В языке \ot{} в проверке типа (\verb'v IS T') или в охране типа (\verb'v(T)'), 
тип \verb'T' должен быть расширением статического типа переменной \verb'v'.

\Message{E}{043}{неверный тип результата}

Тип не может быть типом результата функции (ограничение языка, или
реализации).

\Message{E}{044}{несовместимые типы результата}

Тип результата процедуры-функции не соответствует указанному в
FORWARD-описании, или в описании замещаемого метода.

\Message{E}{046}{незаконное использование типа открытого массива}

Тип открытого массива (\verb'ARRAY OF') можно использовать лишь
как базовый тип указателя, тип элемента открытого массива или тип
формального параметра.

\Message{E}{047}{фактических параметров меньше, чем формальных}

Число фактических параметров в вызове процедуры меньше, чем число
формальных параметров.

\Message{E}{048}{фактических параметров больше, чем формальных}

Число фактических параметров в вызове процедуры больше, чем число
формальных параметров.

\Message{E}{049}{SEQ-параметр должен быть типа SYSTEM.BYTE или SYSTEM.LOC}

SEQ-параметр должен быть последовательностью байтов.

\Message{E}{050}{это не массив}
\Message{E}{051}{это не запись}
\Message{E}{052}{это не указатель}
\Message{E}{053}{это не множество}

Компилятор ожидал в указанной позиции объект данного типа.

\Message{E}{054}{это не переменная}

Компилятор ожидал в указанной позиции переменную (обозначение).

\Message{E}{055}{это не процедура: \%s}
(имя процедуры)

Компилятор ожидал в указанной позиции обозначение процедуры.

\Message{E}{057}{вызов суперметода разрешается только в переопределении этого метода}

Вызов суперметода (метода, прикрепленного к базовому типу)
разрешается только в переопределении этого метода. Например:

\begin{verbatim}
PROCEDURE (p: P) Foo;
BEGIN
  p.Foo^
END Foo.
\end{verbatim}

\Message{E}{058}{метод не определен для базового типа}

В вызове суперметода (метода, прикрепленного к базовому типу)
\verb'p.Foo^' либо метод \verb'Foo' не описан для базового типа
\verb'p', либо базового типа нет.

\Message{E}{059}{это не указатель и не VAR-параметр типа записи}

\ot{} компилятор сообщает об этой ошибке в следующих случаях:
\begin{itemize}
\item в проверке типа \verb'v IS T' или охране типа \verb'v(T)', \verb'v'
 должно быть обозначением либо указателя, либо VAR-параметра типа записи;
 \verb'T' должен быть типом указателя или записи.
\item в описании метода, получатель должен быть либо VAR-параметром типа
 записи, либо параметром по значению типа указателя.
\end{itemize}

\Message{E}{060}{указатель не на запись и не на массив}

В языке \ot{} базовый тип указателя должен быть массивом или записью.
Например, описание \verb'TYPE P = POINTER TO INTEGER' запрещено.

\Message{E}{061}{размерность слишком велика или отрицательна}

Второй параметр функции LEN либо отрицателен, либо больше, чем 
наибольшая размерность массива.

\Message{E}{062}{указатель не на запись}

\ot{} компилятор сообщает об этой ошибке в следующих случаях:
\begin{itemize}
\item в проверке типа \verb'v IS T' или охране типа \verb'v(T)', 
 если \verb'v' --- указатель, то он должен быть указателем на запись.
\item в описании метода, если получатель --- указатель, то он 
должен быть указателем на запись.
\end{itemize}

\Message{E}{064}{базовый тип конструктора открытого массива должен быть простым}

Базовый тип конструктора (\verb'ARRAY OF T{}') не может быть типом
записи или массива.

\Message{E}{065}{тип записи из другого модуля}

Метод, прикрепленный к типу записи, должен описываться в том же модуле,
что и этот тип записи.

\Message{E}{067}{тип получателя должен экспортироваться: \%s}
(имя типа)

Тип получателя экспортируемого метода тоже должен экспортироваться.

\Message{E}{068}{этот метод нельзя применять к записи}

Получатель метода имеет тип указателя, поэтому метод не может быть
вызван для обозначения, имеющего тип записи. Заметьте, что если
получатель метода имеет тип записи, то такой метод может быть вызван 
и для обозначения, имеющего тип указателя.

\Message{E}{069}{неверный вид получателя}

Вид получателя в переопределении метода не соответствует предыдущему
определению.

\Message{E}{071}{необероновский тип в обероновской конструкции}

Необероновский тип, или объект такого типа (импортированный из
необероновского модуля, или описанный с явным указанием языка),
нельзя использовать в специфических 
\ot{} конструкциях (методы, охрана типа и~т.п.).

\Message{E}{072}{неверный порядок переопределения метода}

Метод для расширения типа описан раньше, чем метод с тем же именем
для базового типа.

\Message{E}{074}{переопределенный метод должен экспортироваться}

Переопределенный метод должен экспортироваться, если и тип его 
получателя, и переопределивший его метод экспортируются.

\Message{E}{075}{функция без RETURN}

Процедура-функция не содержит оператора \verb'RETURN' и поэтому не может 
возвращать результат.

\Message{E}{076}{ожидалось выражение}

В указанной позиции ожидалось выражение.

\Message{E}{078}{SIZE (TSIZE) не применима к открытому массиву}

В стандарте языка, стандартные функции \verb'SIZE' и \verb'TSIZE' 
нельзя применять для определения размера обозначения или типа открытого
массива. Если разрешены расширения языка, то компилятор позволяет
применять \verb'SIZE' к обозначению открытого массива, но не к типу.

\Message{E}{087}{выражение должно быть константным}

Компилятор не может вычислить значение этого выражения при компиляции.
Оно должно быть константным по правилам языка.

\Message{E}{088}{идентификатор не совпадает с именем блока}

Идентификатор в конце процедуры или модуля не совпадает
с указанным в заголовке. Эта ошибка может возникнуть
в результате неверного соответствия \verb'END'ов с
заголовками.

\Message{E}{089}{нереализованная процедура "\%s"}

Экспортированная или предописанная процедура не описана.
Необходимо предоставить тело процедуры.

\Message{E}{090}{ожидалась обычная процедура}

Функция вызвана, как обычная процедура. Процедура-функция должна вызываться
в выражении. Результат функции можно игнорировать только для функции,
определенной как 
\verb'"C"', \verb'"Pascal"', \verb'"StdCall"' или \verb'"SysCall"'.
См. \ref{multilang:direct}.

\Message{E}{091}{вызов обычной процедуры в выражении}

Вызов обычной процедуры в выражении.

\Message{E}{092}{кодовая процедура в определяющем модуле}

\Message{E}{093}{запрещено в определяющем модуле}

Эти ошибки вызываются, когда в определяющем модуле используются 
средства языка, недопустимые в нем:
\begin{itemize}
\item локальные модули
\item подробное описание скрытого типа
\item предописание процедуры
\item тело процедуры или модуля
\item параметры по чтению
\end{itemize}

\Message{E}{094}{разрешено только в определяющем модуле}

Эта ошибка вызывается, когда средство языка, разрешенное 
только в определяющем модуле (переменные и поля записи по чтению)
используется где-либо еще (расширенная \mt{}).

\Message{E}{095}{разрешено только в глобальном контексте}

Указанное средство языка разрешено только в глобальном контексте.
К таковым относятся:

\begin{itemize}
\item подробное описание скрытого типа (\mt{})
\item символ экспорта (\ot{})
\item определение метода (\ot{})
\end{itemize}

\Message{E}{096}{нереализованный скрытый тип "\%s"}

Скрытый тип, описанный в определяющем модуле, должен быть
подробно описан в реализующем.

\Message{E}{097}{нереализованный предописанный тип "\%s"}

Тип \verb'T' может быть впервые упомянут в описании типа указателя,
напр.:

\verb'    TYPE Foo = POINTER TO T;'

Такой тип \verb'T' впоследствии должен быть описан, в том же контексте.

\Message{E}{098}{разрешено только для параметра по значению}

Средство языка, применимое только к параметрам по значению
(но не к \verb'VAR' параметрам):

\begin{itemize}
\item символ параметра по чтению
\item значение параметра по умолчанию
\end{itemize}

\Message{E}{099}{RETURN не из тела процедуры}

В языке \ot{}, оператор \verb'RETURN' не разрешен в теле модуля.

\Message{E}{100}{неверный порядок описаний}

В языке \ot{} все описания констант, типов и переменных в 
одной последовательности описаний должны предшествовать
описаниям процедур.

\Message{E}{102}{расширение языка запрещено: \%s}
(спецификация)

Эта ошибка вызывается средством языка, которое можно использовать
лишь при разрешенных расширениях языка.
См. опции \OERef{M2EXTENSIONS} и \OERef{O2EXTENSIONS}.

\Message{E}{107}{не должно быть меньше 0}

Значение константного выражения отрицательно там, где это запрещено:
\begin{itemize}
\item второй операнд в \verb'DIV' и \verb'MOD'
\item число повторений в конструкторе массива (\verb'expr BY count')
\end{itemize}

\Message{E}{109}{предописанный тип не может быть скрытым}

Тип \verb'T', используемый до описания 
(как в \verb'TYPE Foo = POINTER TO T') не может быть описан как
скрытый тип, т.е. как \verb'TYPE T = <opaque type>'.

\Message{E}{110}{неверная длина, ожидалось \%d}
(ожидаемое число элементов)

Неверное число элементов в конструкторе массива.

\Message{E}{111}{число повторений должно быть целым}

Число повторений в конструкторе массива должно иметь целый числовой тип.

\Message{E}{112}{ожидалось значение для поля "\%s"}
(имя поля)

Конструктор записи не содержит выражения для указанного поля записи.

\Message{E}{113}{нет варианта для этого значения селектора}

Эта ошибка возникает, если в конструкторе записи с вариантной частью
задано значение селектора, для которого в описании типа
нет варианта, и если при этом часть \verb'ELSE' отсутствует.

\Message{E}{114}{имя метода "\%s" совпадает с именем поля}

Имя описываемого метода совпадает с именем какого-либо поля
соответствующей записи, или одного из ее базовых типов.

\Message{E}{116}{поле "\%s" не экспортируется}
(имя поля)

Указанное поле не экспортируется; поставьте знак экспорта в 
описании записи.

%E117 type of "%s" is not defined yet % !!!
%(name)
%
%A type of of this object is not defined yet.

\Message{E}{118}{необероновская запись не может быть расширением}

Тип записи может быть расширением другого типа, только если это --
Обероновский тип запись.

\Message{E}{119}{вариантная часть в обероновской записи}

Запись с вариантными частями не может быть Обероновской.

\Message{E}{120}{поле обероновского типа в необероновской записи}

Это считается ошибкой, поскольку сборщик мусора не отслеживает
не-Обероновские записи, и ссылка на объект может быть потеряна.

\Message{E}{121}{неверное использование обозначения типа "\%s"}

Обозначение типа не может использоваться в позиции оператора.

\Message{E}{122}{нарушение границ}

Значение, известное в момент компиляции, выходит за границы.

\Message{E}{123}{эта переменная только по чтению}

Обозначение, отмеченное "по чтению", не может находиться в 
позиции, где его значение может измениться.

\Message{E}{124}{нижняя граница диапазона больше верхней}

Нижняя граница диапазона больше верхней.

\Message{E}{125}{EXIT вне цикла LOOP}

Оператор \verb'EXIT' означает завершение содержащего его цикла
\verb'LOOP'.
Указанный же \verb'EXIT' не находится внутри \verb'LOOP'.

\Message{E}{126}{эта метка варианта уже встречалась}

В операторе \verb'CASE' все метки должны иметь разные значения.
Значение метки в указанной позиции уже встречалось
в этом операторе \verb'CASE'.

\Message{E}{128}{переменная FOR-цикла должна быть локальной}

Переменная цикла \verb'FOR' должна быть локальной переменной процедуры
или модуля, в теле которых содержится цикл.

\Message{E}{129}{выражений больше, чем полей в типе записи}

В конструкторе записи больше выражений, чем полей в типе записи
(или в соответствующем варианте вариантной записи).

\Message{E}{131}{нулевой шаг в цикле FOR}

В цикле \verb'FOR' шаг не может быть равен нулю.

\Message{E}{132}{должно быть обозначением открытого массива}

Если расширения языка выключены, то стандартная процедура
\verb'HIGH' может применяться только к открытым массивам,
иначе --- к любым массивам.

\Message{E}{133}{слишком длинный базовый тип множества (длина > \%d)}

Компилятор имеет ограничение на длину базового типа множества
(\verb'MAX(base)-MIN(base)+1'). Заметим, что нижняя граница диапазона
при этом может быть любой, напр. следующие типы разрешены:

\verb'    SET OF [-256..-5]'\\
\verb'    SET OF [MAX(INTEGER)-512..MAX(INTEGER)]'

\Message{E}{134}{должен быть беззнаковым}

Параметр указанной стандартной процедуры должен быть значением
беззнакового типа.

\Message{E}{135}{должен быть указателем}

Параметр указанной стандартной процедуры должен иметь тип указателя.

{\bf Замечание:} тип  \verb'SYSTEM.ADDRESS' определяется как
\verb'POINTER TO LOC'.

\Message{E}{136}{должен быть обозначением типа}

Параметр указанной стандартной процедуры должен быть обозначением типа.

\Message{E}{137}{числовая константа не занимает объема памяти}

Компилятор ожидал в данном месте значение, которое занимает определенный
известный объем памяти. Поэтому числовая константа не может находиться
в этой позиции.

\Message{E}{139}{должен быть квалидентом, обозначающим переменную}

По стандарту ISO, в данном контексте (напр. в качестве параметра процедуры 
\verb'SIZE') требуется "полное обозначение" ("entire designator"). 
Это может быть либо переменная (в~т.ч. формальный параметр), либо
идентификатор поля записи внутри оператора \verb'WITH', относящегося к 
этой записи.

\Message{E}{140}{процедуры прерываний еще не реализованы}

ETH Оберон-2 компиляторы  поддерживают так называемые процедуры
прерываний, помечаемые символом "+".

\verb'    PROCEDURE + Foo;'

В XDS это еще не реализовано.

\Message{E}{141}{скрытый тип не может быть обероновским указателем}

Скрытый тип языка \mt{} не может определяться как Обероновский указатель.
См. главу \ref{multilang}.

\Message{E}{143}{в Обероне запрещено}

Эта ошибка выдается для средств языка, разрешенных в Модуле-2, но
запрещенных в Обероне-2:
\begin{itemize}
\item перечислимые типы
\item типы диапазона
\item локальные модули
\end{itemize}

\Message{E}{144}{в проверке типа смешаны указатель и запись}

В языке \ot{}, в проверке типа \verb'v IS T' или в охране типа \verb'v(T)',
\verb'v' и \verb'T' должны одновременно быть либо указателями, либо записями.

\Message{E}{145}{переменная FOR-цикла не может быть формальным параметром}

В ISO стандарте языка \mt{}, управляющая переменная цикла \verb'FOR'
не может быть формальным параметром (ни \verb'VAR', ни по значению).

\Message{E}{146}{управляющая переменная не может экспортироваться}

Переменная, используемая как управляющая переменная цикла \verb'FOR' или 
\ot{}-оператора \verb'WITH', не может экспортироваться.

\Message{E}{147}{угроза значению контрольной переменной}

\Message{E}{158}{угроза значению контрольной переменной "\%s"}
(имя переменной)

Значение управляющей переменной цикла \verb'FOR' или 
\ot{}-оператора \verb'WITH'
не может изменяться внутри тела оператора, в том числе и в процедурах,
вызываемых из тела оператора. 
Действия, угрожающие таким изменением --- это присваивание и передача как
\verb'VAR' параметр в описанную пользователем или в стандартную
(\verb'ADR', \verb'INC', \verb'DEC' и~т.п.) процедуру.
Компилятор сообщает об ошибке 158, если может указать 
точное место угрозы.

\Message{E}{148}{финализация разрешается только для модуля}

Тело процедуры не может содержать секции финализации.

\Message{E}{149}{RETRY вне исключительной части блока}

Указанный оператор \verb'RETRY' находится вне исключительной части блока.

\Message{E}{150}{неверная спецификация языка}

Значение в явном указании языка должно быть одной из строк
\verb'"Modula"', \verb'"Oberon"',
\verb'"C"',\verb'"Pascal"', \verb'"SysCall"' или \verb'"StdCall"',
или соответствующим числовым значением. Мы рекомендуем использовать строки;
числовые значения сохранены лишь для обратной совместимости.

\Message{E}{151}{должно быть целого типа}

Ожидалась переменная целочисленного типа.

\Message{E}{152}{несовместимые соглашения о связях: "\%s" "\%s"}
\Message{E}{153}{несовместимые соглашения о связях}

Процедуры имеют несовместимые соглашения о связях. Ошибка вызывается в 
следующих случаях:
\begin{itemize}
\item процедура присваивается переменной типа процедуры;
\item процедура передается как параметр;
\item сравниваются два процедурных значения.
\end{itemize}
Компилятор сообщает об ошибке 152, если он может указать несовместимые типы,
в противном случае --- об ошибке 153.

\Message{E}{154}{процедура "\%s" не соответствует предыдущему определению; было: \%s стало: \%s}
(имя процедуры,процтип,процтип)
\Message{E}{155}{процедура "\%s" не соответствует предыдущему определению}
(имя процедуры)

Заголовок процедуры должен иметь то же число параметров,
те же способы передачи (\verb'VAR' или по значению) и те же типы параметров,
что и в предыдущем определении. Предыдущее определение может быть 
следующих видов:
\begin{itemize}
\item описание процедуры в определяющем модуле;
\item FORWARD описание процедуры;
\item описание метода для базового типа.
\end{itemize}

Компилятор сообщает об ошибке 154, если он может указать несовместимые типы,
в противном случае --- об ошибке 155.

\Message{E}{156}{ожидалось обозначение процедуры}

Обозначение, выглядящее как вызов (напр. \verb'Foo(...)'), не 
обозначает процедуру.

%%%% E157 object must be exported                            % !!!

\Message{E}{159}{конструктор должен быть множеством, массивом или записью}

Объект, выглядящий, как конструктор (напр. \verb'Foo{...}'),
начинается с идентификатора, не являющегося типом множества, массива или
записи.

\Message{E}{160}{неверный специальный вид параметра: ожидалось NIL} %???

В настоящей версии реализован только один специальный вид
VAR-параметра: \verb'VAR [NIL]'. 
Это означает, что \verb'NIL' можно передавать в этот параметр.

\Message{E}{161}{ожидался параметр вида VAR [NIL]}

Параметр функции \verb'SYSTEM.VALID' должен быть вида \verb'VAR [NIL]'.

\Message{E}{162}{\%s должен быть одним из \%\{\} (не "\%s")} %???
(параметр компилятора, множество разрешенных значений, значение)

Об ошибке сообщается при неправильной установке
параметров компилятора \verb'ALIGNMENT', \verb'ENUMSIZE'
или \verb'SETSIZE'.

\Message{E}{163}{control variable cannot not be volatile}
% ???

Управляющая переменная цикла \verb'FOR' не может быть помечена как
volatile. См.  опцию \OERef{VOLATILE}.

\Message{E}{200}{еще не реализовано}

Это средство языка еще не реализовано.

\Message{E}{201}{вещественное переполнение (исчерпание) в константном выражении}

При вычислении компилятором значения константного выражения
произошло вещественное переполнение (исчерпание).

\Message{E}{202}{целое переполнение в константном выражении}

При вычислении компилятором значения константного выражения
произошло целое переполнение.

{\bf Замечание:} Компилятор при работе с целыми числами использует
64-битовую знаковую арифметику. Поэтому в следующем примере 
будет сообщено об ошибке в операторе присваивания, а не в описании констант:

\begin{verbatim}
MODULE Test;

CONST
  VeryBigConstant = MAX(CARDINAL)*2;            (* OK *)
  NotVeryBigConstant = VeryBigConstant DIV 4;   (* OK *)

VAR c: CARDINAL;

BEGIN
  c:=NotVeryBigConstant;  (* OK *)
  c:=VeryBigConstant;     (* expression out of bounds *)
END Test.
\end{verbatim}

\Message{E}{203}{деление на ноль}

Второй операнд в \verb'DIV', \verb'MOD', \verb'REM' или \verb'"/"' 
равен нулю.

\Message{E}{206}{длина массива слишком велика или отрицательна}

Длина массива отрицательна или превосходит максимально возможную в
данной реализации.

\Message{E}{208}{неисполнимый оператор CASE}

Об этой ошибке сообщается, если выражение в операторе \verb'CASE'
может быть вычислено в момент компиляции и при этом варианта, 
соответствующего ему, нет, а часть \verb'ELSE' опущена. При исполнении
программы такая ситуация привела бы к исключению
\verb'caseSelectException'.

\Message{E}{219}{слишком много вложенных открытых массивов (максимум \%d)}
(максимальное значение)

Компилятор (точнее, система поддержки исполнения) накладывает ограничение
на количество вложенных типов открытых массивов (т.е. на размерность).
Для массивов фиксированного размера никакого ограничения нет, поскольку они 
не требуют специального контроля системы поддержки исполнения.

\Message{E}{220}{слишком большая глубина расширений записи (максимум \%d)}
(максимальное значение)

Система поддержки исполнения накладывает ограничение
на количество расширений типа записи. Это необходимо для эффективной
реализации проверок и охран типа.

\Message{E}{221}{слишком большая глубина вложенности процедур (максимум \%d)}
(максимальное значение)

Компилятор накладывает ограничение на глубину вложенности процедур.
При этом модули, вложенные в процедуры, не считаются; считается только
глубина вложенности описаний процедур.

\Message{E}{281}{метод не имеет процедурного значения}

Метод не может присваиваться переменной процедурного типа.

\Message{E}{282}{локальная процедура "\%s" не имеет процедурного значения}
(имя процедуры)

Локальная процедура другой процедуры не может присваиваться переменной
процедурного типа.

\Message{E}{283}{кодовая (или внешняя) процедура не имеет процедурного значения}

Кодовая или внешняя процедура не может присваиваться переменной
процедурного типа.

\section{Ошибки чтения/записи символьных файлов}

\Message{F}{190}{неверный заголовок символьного файла "\%s"}
(имя модуля)

Символьный файл данного модуля испорчен. Его нужно перекомпилировать.

\Message{F}{191}{неверная версия символьного файла "\%s" (\%d вместо \%d)}
(имя модуля, версия симфайла, текущая версия)

Символьный файл данного модуля порожден слишком старой или слишком
новой версией компилятора. Перекомпилируйте модуль, или возьмите 
самую свежую версию компилятора и/или симфайла.

\Message{F}{192}{несовпадение ключей импортируемого модуля "\%s"}
(имя модуля)

Эта ошибка возникает, когда интерфейс какого-либо модуля изменился,
но не все его клиенты (импортирующие из него модули) перекомпилированы.
Пусть, например, \verb'A' импортирует \verb'B' и \verb'M', а
\verb'B', в свою очередь, импортирует \verb'M':

\begin{verbatim}
DEFINITION MODULE M;   DEFINITION MODULE B;     MODULE A;
                       IMPORT M;                IMPORT M,B;
END M.                 END B.                   END A.
\end{verbatim}

Перекомпилируем \verb'M.def', \verb'B.def' и затем снова \verb'M.def'.
Теперь эта ошибка возникнет при компиляции
\verb'A.mod', поскольку ключ версии модуля 
\verb'M', неявно доступного через \verb'B',
не совпадает с ключом версии \verb'M', импортируемого напрямую.

Для избавления от этой ошибки модули должны компилироваться в
правильном порядке. Мы рекомендуем использовать предоставляемую
\xds{} возможность компилировать Вашу программу в режимах
MAKE или PROJECT. Если Вы всегда будете пользоваться ею, то 
данная ошибка никогда не будет возникать.

\Message{F}{193}{изменение символьного файла запрещено}

\ot{} компилятор при каждой компиляции модуля создает временный 
символьный файл, сравнивает его с существующим, и заменяет существующий
на него, если необходимо.
Когда опция \OERef{CHANGESYM} установлена OFF (по умолчанию), компилятор 
сообщает об ошибке, если символьный файл (а с ним и интерфейс модуля)
изменились, и не заменяет старый символьный файл.

Замечание: Если опция \OERef{M2CMPSYM} установлена ON, то же самое применимо
к компиляции \mt{} определяющего модуля, т.е. для изменения 
интерфейса модуля необходимо выставить опцию
\OERef{CHANGESYM}.

\Message{F}{194}{имя модуля не совпадает с именем симфайла "\%s"}
(имя модуля)

Имя модуля, указанное в секции \verb'IMPORT', должно совпадать 
с настоящим именем, указанным в заголовке модуля.

\Message{F}{195}{не могу прочесть симфайл "\%s", порожденный \%s}
(имя модуля, название компилятора)

Символьный файл указанного модуля порожден другим  компилятором \xds{}.
Компиляторы в объектный код понимают символьные файлы, порожденные
{\bf XDS-C} компилятором для той же платформы, но не наоборот.

\section{Внутренние ошибки}

Здесь перечислены внутренние ошибки компилятора. Иногда такая
ошибка может возникнуть в результате неуспешного восстановления
после предыдущих ошибок в тексте. В любом случае, 
сообщите нам о возникновении такой ошибки, указав:
\begin{itemize}
\item версию компилятора
\item описание Вашей платформы (OS, CPU)
\item минимальный исходный текст, на котором возникает ошибка.
\end{itemize}

\Message{F}{103}{INTERNAL ERROR(ME): ожидалось значение}
\Message{F}{104}{INTERNAL ERROR(ME): ожидалось обозначение}
\Message{F}{105}{INTERNAL ERROR(ME): ожидался оператор}
\Message{F}{106}{INTERNAL ERROR(ME): тип узла = NIL}
\Message{F}{142}{INTERNAL ERROR(ME): не могу сгенерировать}

\Message{F}{196}{INTERNAL ERROR: неверный идент \%d при чтении симфайла "\%s"}
\Message{F}{197}{INTERNAL ASSERT(\%d) при чтении симфайла "\%s"}

\section{Предупреждения}

Во многих случаях предупреждения компилятора помогают найти какой-нибудь
серьезный недостаток программы. Поэтому мы рекомендуем не выключать
выдачу предупреждений и тщательно проверять их. Нам самим они не раз
помогали быстро найти и исправить ошибку
(система \xds{} сама написана на \xds{} Обероне-2 и Модуле-2).

Здесь мы опишем только предупреждения, сообщаемые обоими компиляторами
{\bf XDS-C} и {\bf Native XDS}. У каждого из них есть и свои специфические
предупреждения; но компиляторы в объектный код производят более
подробный анализ программы, и генерируют больше предупреждений.

\Message{W}{300}{переменная описана, но не использована}

Переменная не нужна. Она не экспортируется, не присваивается, не
передается как параметр и не используется в выражениях. Компилятор
не будет отводить для нее память.

\Message{W}{301}{параметр не используется}

Параметр не используется в теле процедуры.

\Message{W}{302}{присвоенное значение не используется}

В настоящей версии это предупреждение не выдается.

\Message{W}{303}{процедура описана, но не использована}

Процедура не экспортируется, не вызывается и не присваивается.
Компилятор не будет генерировать ее.

\Message{W}{304}{возможно использование до инициализации "\%s"}
(имя переменной)

Это предупреждение выдается, если значение переменной в данный момент 
его использования может быть неопределено. Однако это --- всего лишь
предупреждение, и в сложных ситуациях компилятор может выдать его
ошибочно.
Так, в следующем примере переменной \verb'"y"' будет присвоено значение 
при первой итерации цикла, но компилятор выдаст предупреждение, поскольку 
он не отслеживает последовательность исполнения цикла \verb'FOR'.

\begin{verbatim}
PROCEDURE Foo;
  VAR x,y: INTEGER;
BEGIN
  FOR x:=0 TO 2 DO
    IF x = 0 THEN y:=1
    ELSE INC(y)  (* здесь выдается предупреждение *)
    END;
  END;
END Foo;
\end{verbatim}

Для глобальных переменных это предупреждение не выдается.

\Message{W}{305}{константа описана, но не использована}

В настоящей версии это предупреждение не выдается.

\Message{W}{310}{бесконечный цикл}

Исполнение этого цикла (\verb'LOOP', \verb'WHILE' or \verb'REPEAT')
не может прекратиться.
Это означает, что все операторы после цикла недостижимы, и компилятор
не будет их генерировать. Проверьте, что цикл сделан бесконечным намеренно.

\Message{W}{311}{недостижимый код}

Управление никогда не может перейти к этому участку кода; компилятор
не будет его генерировать (удаление "мертвого" кода). 
Это может быть участок после операторов \verb'RETURN',
\verb'ASSERT(FALSE)', \verb'HALT', после бесконечного цикла,
внутри условного оператора с тождественно ложным условием
(\verb'IF FALSE THEN'), и~т.п.

\Message{W}{312}{цикл исполняется один раз}

Цикл исполняется один раз. Примеры:

\verb'    FOR i:=1 TO 1 DO ... END;'

\verb'    LOOP ...; EXIT END;'

Проверьте, что это сделано намеренно.

\Message{W}{314}{значение "\%s" известно заранее}

Компилятор знает значение переменной (ввиду распространения константы)
и вместо доступа к переменной использует это известное значение.
Для текста

\verb'    i:=5; IF i = 5 THEN S END;'

компилятор сгенерирует такой же код, как для

\verb'    i:=5; S;'

Для глобальных переменных это предупреждение не выдается.

\Message{W}{315}{разыменование NIL}

Компилятор знает, что в момент разыменования значение указателя 
равно NIL (ввиду распространения константы). Например:

\verb'    p:=NIL;'\\
\verb'    p^.field:=1;'

Код будет сгенерирован, и при исполнении вызовет исключение
"invalidLocation".

Для глобальных переменных это предупреждение не выдается.

\Message{W}{316}{SYSTEM процедура, не описанная в ISO стандарте}

Это предупреждение выдается, чтобы облегчить перенос Вашей
программы на другие компиляторы языка \mt{}.

\Message{W}{317}{WITH, управляемый VAR параметром: возможна угроза}

Параметр--переменная типа указателя используется как управляющая переменная
\ot{} оператора \verb'WITH'.
Компилятор не может проверить, что ее значение не изменяется 
внутри \verb'WITH'. 
Так, в следующем примере \verb'"ptr"', а, значит, и \verb'"p"' 
становится равным \verb'NIL' внутри \verb'WITH':

\begin{verbatim}
VAR ptr: P;

PROCEDURE proc(VAR p: P);
BEGIN
  WITH p: P1 DO
    ptr:=NIL;
    p.i:=1;
  END;
END proc;

BEGIN
  proc(ptr);
END
\end{verbatim}

Мы рекомендуем не использовать VAR-параметры типа указателя
как управляющие переменные в операторах \verb'WITH'.

\Message{W}{318}{неисполняемый FOR цикл}

Цикл \verb'FOR' избыточен (и не генерируется), если его границы
определены в момент компиляции, и он должен исполниться ноль раз,
или если тело цикла пусто.

\section{Предупреждения, относящиеся к прагмам}

\Message{W}{320}{опция "\%s" не описана}

Используется неописанная опция; ее значение полагается равным \verb'FALSE'.

\Message{W}{322}{параметр "\%s" не описан}

Используется неописанный параметр компилятора; значение неопределено.

\Message{W}{321}{опция "\%s" уже описана}
\Message{W}{323}{параметр "\%s" уже описан}

Данная опция (параметр) уже описана; вторая декларация игнорируется.

\Message{W}{390}{устаревший синтаксис прагмы}

Используется устаревший синтаксис. Следующая версия 
компилятора перестанет его понимать. Рекомендуем переписать
прагму, используя новый синтаксис.

\section{Предупреждения генератора объектного кода}

\Message{W}{900}{избыточный код удаляется}

Предупреждение выдается, если участок кода не влияет на исполнение,
например:

\verb'    i:=1;'\\
\verb'    i:=2;'

Первое присвоение здесь избыточно и будет удалено.

\Message{W}{901}{избыточный код не удаляется - возможно исключение}

То же, что и W900, но избыточный код оставляется, поскольку он
может возбудить исключение. Например:

\verb'    i:=a DIV b; (* исключение при b<= 0 *)'\\
\verb'    i:=2;'

\Message{W}{902}{константное условие}

Предупреждение выдается, если логическое выражение может быть вычислено
во время компиляции, например:

\verb'    IF (i=1) & (i=1) THEN (* второе выражение - TRUE *)'

or

\verb'    j:=2;'\\
\verb'    IF (i=1) OR (j#2) THEN (* второе выражение - FALSE *)'

\Message{W}{903}{результат функции не используется}

Компилятор игнорирует результат процедуры-функции. Например:

\verb'    IF Foo() THEN END;'

\Message{W}{910}{возбуждается исключение realValueException}
\Message{W}{911}{возбуждается исключение wholeValueException}
\Message{W}{912}{возбуждается исключение wholeDivException}
\Message{W}{913}{возбуждается исключение indexException}
\Message{W}{914}{возбуждается исключение rangeException}
\Message{W}{915}{возбуждается исключение invalidLocation}

Предупреждение этой группы выдается, если компилятор определил, что
данный фрагмент программы возбудит соответствующее исключение.
Код для этого фрагмента будет удален, и заменен на вызов процедуры,
возбуждающей данное исключение.

\section{Ошибки генератора объектного кода}

Здесь описаны ошибки, сообщаемые генератором объектного кода --- 
выходным концом компилятора. Генератор кода вызывается только
после безошибочного разбора программы парсером.

\Message{F}{950}{не хватает памяти}

Компилятор не может сгенерировать модуль. Попробуйте 
изменить \OERef{HEAPLIMIT} или скомпилировать модуль отдельно
(не в режимах MAKE или PROJECT).       % ref !!!
Почти все модули компилируются при значении параметра \OERef{HEAPLIMIT},
равного 8 мегабайт.
Исключения - это очень большие модули, вроде \verb'Windows.def' 
(интерфейс к Win32 API), или модули, содержащие очень большие процедуры
(более 500 строк). Объем памяти, требуемой генератору кода, в основном 
зависит от размеров отдельных процедур (и тел модулей). %???

\Message{F}{951}{слишком сложное выражение}

Компилятор не может сгенерировать код для этого выражения, оно 
слишком сложно. Упростите выражение.

\Message{F}{952}{нереализованное преобразование типа}

Компилятор не умеет генерировать требуемое преобразование типа.

\section{Предупреждения C-генератора}

\Message{W}{350}{непереносимое преобразование типа: размер неопределен}

Компилятор порождает преобразование типа, которое может быть
непереносимым. Проверьте правильность текста, или обратите внимание
на возможное предупреждение C-компилятора.

\Message{W}{351}{опция NOHEADER действует только в C-модулях}
\Message{W}{352}{опция NOCODE действует только в C-модулях}

Опции \OERef{NOHEADER} и \OERef{NOCODE} 
имеют смысл только для модулей, определенных как
\verb'"C"', \verb'"StdCall"' или \verb'"SysCall"'. 
См. \ref{multilang:direct}.

\Message{W}{353}{порочный круг в C коде}

Порожденный код содержит порочный круг; например, 
описание \verb'A' зависит от \verb'B' и наоборот.
Это не обязательно ошибка; порожденный код может быть верным.

\section{Ошибки C-генератора}

Здесь описаны ошибки, сообщаемые генератором C-кода --- 
выходным концом компилятора. Генератор кода вызывается только
после безошибочного разбора программы парсером.

\Message{E}{1001}{параметр "\%s" не описан}
(имя параметра)

В строке протокола кодовой процедуры использовано неизвестное имя
параметра.

\Message{E}{1002}{не могу породить рекурсивное определение типа}
\Message{E}{1018}{не могу породить рекурсивное описание типа}

В C, рекурсивное описание типа должно использовать
struct, тогда как в языках
\mt{}/\ot{} это делается с помощью предописания типа указателя.
Следующие типы не могут быть описаны в C:

\verb'    TYPE P = POINTER TO P;'

или

\verb'    TYPE P = POINTER TO A;'\\
\verb'         A = ARRAY [0..1] OF P;'

Мы считаем, однако, что в реальном программировании такие типы 
мало для чего нужны.

\Message{E}{1003}{конфликт внешних имен: "\%s.\%s" и "\%s.\%s"}

Транслятор внешние имена (имена экспортируемых объектов) как
\verb'<module name>_<object name>'. Эта ошибка вызывается совпадением
внешних имен двух различных объектов.

\Message{E}{1004}{внешнее имя "\%s.\%s" совпадает со стандартным (xm.kwd)}

То же, что и предыдущая ошибка, но внешнее имя совпадает с одним из имен,
перечисленных в файле \verb'xm.kwd'.

\Message{E}{1005}{нереализованная системная процедура}

Эта стандартная (системная) процедура еще не реализована.

\Message{E}{1006}{длина массива в размерности \%d неизвестна}

Функция \verb'LEN' не применима к параметру процедуры типа открытого 
массива, если процедура имеет конвенцию вызова
\verb'"C"', \verb'"SysCall"' или \verb'"StdCall"'. 
Для нормальных (\ot{}/\mt{}) процедур компилятор передает по 
одному дополнительному параметру на каждую размерность (длину массива
в этой размерности).
Для процедур вида \verb'"C"', \verb'"SysCall"', \verb'"StdCall"' 
передается только адрес массива.

\Message{E}{1007}{размер массива в размерности \%d неизвестен}

Компилятор не может вычислить размер массива.

\Message{E}{1014}{неизвестен размер типа (\%s)}
(тип)

Компилятор не может вычислить размер этого типа.
См. также опцию \OERef{GENSIZE}.

\Message{E}{1015}{слишком много параметров}

Реализация налагает ограничение на количество параметров процедуры
(256). Заметьте, что в исходном тексте та же процедура может иметь
меньше параметров, поскольку добавляются дополнительные параметры для:
\begin{itemize}
\item открытых массивов
\item VAR-параметров типа записи в Обероне-2
\item функций, возвращающих составные типы.
\end{itemize}

\Message{E}{1008}{не могу породить выражение}
\Message{E}{1009}{не могу породить l-value type cast} 
%???
\Message{E}{1010}{не могу породить преобразование типа}
\Message{E}{1011}{не могу породить конструктор}
\Message{E}{1012}{не могу породить оператор}
\Message{E}{1013}{не могу породить конструктор константы этого типа}
\Message{E}{1016}{не могу породить обозначение типа}
\Message{E}{1017}{не могу породить описание типа}
\Message{E}{1019}{не могу породить описание объекта}

Ошибка этой группы означает, что какое-то редкое средство языка
(или их комбинация) еще не реализовано. Пришлите нам сообщение
об ошибке с минимальным текстом, вызывающим ошибку.

