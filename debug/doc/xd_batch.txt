        Параметры запуска из командной строки.
        ======================================

Для запуска отладчика необходимо набрать в командной строке:

xd.exe [ [ ('/'|'-') Опции ]  Имя файла ]

  Опции и параметры программы необходимо указывать хотя бы через
один  пробел.  Опции  программы  включают или задают  режимы  работы
программы. Определены следующие опции:

·  D, d - диалоговый режим;
·  B, b - пакетный режим;
·  S, s - работа с закрытым протоколом;
·  R, r - создать протокол с именем по умолчанию;
·  N, n - выдавать только имя пакета без полного пути;
·  H, h - справка об опциях запуска программы.


        Значения опций, принятые по умолчанию.
        --------------------------------------

  По умолчанию включены опции:  D - диалоговый режим.  Остальные опции
выключены.  При  задании  взаимоисключающих  друг друга  опции будет
включена последняя,  предыдущие - проигнорированы.  При неправильном
задании опции или при задании  неизвестной  опции выдается сообщение
об ошибке и краткая справка об опциях.
  Если   включен  пакетный  режим,   к  имени  пакета  автоматически
добавляеться расширение "XD". Если включен диалоговый режим,к имени
программы автоматически  добавляеться расширение "EXE".  При наличии
у имени файла расширения "EXE" автоматически  включается  диалоговый
режим  работы,  если  не была ранее включена опция работы в пакетном
режиме.
  Если параметров программы больше,  чем требуется, то об этом будет
выдано предупреждение. Лишние параметры будут проигнорированы.



        Входные и выходные данные.
        ==========================

        Входные данные.
        ---------------

        Для  работы пакетного отладчика требуются следующие входные данные:

    ·  пакет отладки;
    ·  импортируемые пакеты;

        а также, возможно:

    ·  файл, содержащий списки путей поиска файлов;
    ·  отлаживаемая программа;
    ·  исходные файлы модулей.

         Пакет (импортируемые пакеты) отладки является обычным текстовым
    файлом, в  котором записано задание на языке отладки.
         Файлы с исходными текстами для модулей необходимы в основном для
    работы при переходе в диалоговый режим работы из пакета.



        Выходные данные.
        ----------------

        В процессе работы пакетный отладчик создает протокол отладки,
    который  содержит результаты его работы. Протокол  отладки  может
    выдаваться  как на экран, так и в файл, в зависимости от  режима,
    установленного  в  пакете  отладки.  В  случае,  когда   протокол
    выдается  в  файл,  после завершения работы отладчика  появляется
    файл,  с  тем  именем,  которое  было  задано  пользователем  для
    формирования  протокола  отладки.  По  своей  структуре  протокол
    отладки,  выданный  в  файл, является обычным  текстовым  файлом.
    Протокол отладки содержит следующие виды информации:
    ·  сообщения об исполняемом пакете: название пакета отладки
    ·  трасса пакета: последовательность исполняющихся операторов пакета
    ·  трасса отлаживаемой программы: последовательность исполняющихся
       (дизассемблированных) команд отлаживаемой программы; последовательность
       строк исходного текста; а так же смешаный вариант: с привязкой кода
       к строкам, и наоборот;
    ·  результаты выполнения операторов пакета;
    ·  сообщения  отладчика об ошибках: номер строки,  в  которой
       произошла ошибка, и краткое сообщение, указывающие на причину;
    ·  информационные сообщения отладчика об произошедших остановах,
       вызовах подпрограмм и др.




        Структура  пакета отладки.
        ==========================

        Представленная ниже структура пакета отладки является рекомендуемой
для использования, но не обязательной.

< Импорт >
< Формирование среды для отлаживаемой программы >
< Формирование структуры протокола. >
< Подготовка общих данных программы для отладки >
. . .
< НАЧАЛО_ВАРИАНТА Название_Варианта >
  < Подготовка данных варианта >
  < Печать данных >
  < ВЫПОЛНИТЬ Адрес >
  < Печать результатов >
< КОНЕЦ_ВАРИАНТА Название_Варианта >
. . .
< Завершение пакета >
< Процедуры пакета>



        Импорт пакетов. Вызовы процедур из включенных частей.
        =====================================================

        #IMPORT BatchName

        При использовании пакетного отладчика часто возникает необходимость
иметь в пакете отладки набор некоторых специальных фрагментов, в частности:
печать входных и выходных данных, значений регистров, анализ выходных данных,
полученных при исполнении пакета, др.. Все эти действия реализуются достаточно
замкнутыми группами операторов, которые можно пометить в пакете меткой, а в
дальнейшем ссылаться на этот фрагмент (процедуру) по мере необходимости.
Для того, чтобы иметь возможность исполнить процедуру, находящуюся (описанную)
в одном пакете, из другого, необходимо включить в пакет директиву импорта.
При этом из импортирующего пакета становятся видимыми (доступными) все
метки, описанные в импортируемом. Таким образом, появляется возможность
из импортирующего пакета вызывать процедуры, описанные в импортируемом. Стоит
отметить, что пространство меток становится общим, поэтому все имена меток
должны различаться.
        Возврат из процедур, принадлежащих импортируемому пакету, происходит
по обычным правилам. Окончание выполнения пакета происходит либо после
выполнения оператора окончания отладки, либо при выполнении последней строки
в текущем исполняемом пакете, в том числе и в импортируемом.
        При загрузке пакета предварительно строится таблица меток и выполняются
директивы импорта пакетов.


        ERRORS:

007 Batch name missed.
009 Too many nested packages (16)
010 Package <...> recursively imported
011 Incorrect package name <...>
014 Imported package <...> not found.
018 Unknown directive <...>.
111 Label '<...>' already defined
112 Incorrect label
113 Label matches reserved word


        #IMPORT PrintRegisters
        #IMPORT SetBreakpoints
        #IMPORT ErrorHandler



                Операторы языка отладки.
                ========================

        Структура операторов языка пакетной отладки.
        --------------------------------------------

        В языке пакетной отладки
отсутствуют структурные управляющие конструкции и принят построчный формат
записи операторов, т.е. каждый оператор располагается на отдельной строке,
поэтому структуру любого оператора можно описать следующим образом. В начале
строки может находиться метка, помечающая оператор, затем должно быть имя
оператора, далее следуют параметры оператора, перечисленные через запятую,
и, наконец, отделенный хотя бы одним пробелом от последнего параметра, может
располагаться комментарий.
        Метка - это идентификатор, которым обозначается позиция в пакете.
        В зависимости от вида оператора количество и типы его параметров могут
быть различными, к тому же отдельные операторы могут иметь произвольное число
параметров, а для других операторов некоторые из параметров являются
необязательными.
        Передачи управления в пакете выполняются с помощью переходов на метки.
        В качестве символа начала комментария можно использовать символ ";".
        В настоящее время операторы языка отладки в соответствии с их
семантикой можно разделить на 5 функциональных групп, а именно:

   · операторы формирования среды для отлаживаемой программы
   · операторы управления выполнением пакета
   · операторы управления выполнением отлаживаемой программы
   · операторы выдачи и изменения информации
   · операторы управления формированием структуры протокола.



        Операторы формирования среды для отлаживаемой программы.
        ========================================================

        С помощью операторов рассматриваемой группы выполняются
подготовительные действия, необходимые для проведения отладки и тестирования
программ.



        Оператор LOAD. Загрузка программы.
        ----------------------------------

        LOAD Program { Program_Arguments }

        Оператор LOAD осуществляет загрузку отлаживаемой программы
с задаными аргументами и считывает отладочную информацию для каждого из модулей,
из которых она состоит. Отсутствие отладочной информации о модуле не мешает
исполнению программы, однако делает невозможным выполнение каких_либо отладочных
действий с указанным модулем.
        В пакете оператор LOAD должен предшествовать операторам,
которые работают с переменными программы.
        Если не происходит загрузки программы из-за каких-либо ошибок
- выполнение пакета не прекращается, но при этом выдается сообщение.


        ERRORS:

127 Incorrect program name
165 Program name expected
700 Loading <...>: <...>


        LOAD xc =p =a dry
        LOAD dry



        Оператор RESTART. Рестарт программы.
        ------------------------------------

        RESTART

        Оператор RESTART предназначен для рестарта загруженной отлаживаемой
программы. После рестарта состояние программы такое же как после выполнения
оператора LOAD.


        ERRORS:

116 Program not loaded
133 Program can't restarted
135 Restart not allowed


        RESTART



        Операторы управления выполнением пакета.
        ========================================

        Операторы этой группы позволяют управлять выполнением пакета: совершать
условные и безусловные переходы, при необходимости завершать работу пакетного
отладчика, вызывать процедуры, написанные на языке отладки, задавать
эквивалентные имена. Передачи управления и вызовы процедур в пакете реализуются
с помощью переходов на заданные метки.



        Оператор QUIT.
        --------------

        QUIT

        Оператор QUIT завершает выполнение пакета отладки.


        ERRORS:


        QUIT




        Оператор PAUSE. Приостанов выполнения пакета.
        ---------------------------------------------

        PAUSE [ Delay ]

        Оператор PAUSE используется для приостанова выполнения
отладочного пакета. Оператор бывает необходим, когда пользователю нужно
посмотреть выводимые отладчиком сообщения на экране. Задержка выполнения
продолжается заданное время или до нажатия пользователем любой клавиши
на клавиатуре.


        ERRORS:

126 Incorrect parameter


        PAUSE
        PAUSE 10



        Операторы GOSUB и RETURN.
        -------------------------

        GOSUB Label
        RETURN

        Оператор GOSUB предназначен для вызова процедуры в пакете
отладки. Действие этого оператора - передача управления на заданную метку в
пакете. Возврат из процедуры обеспечивает оператор RETURN. После
этого оператора передача управления происходит на оператор, непосредственно
следующий за оператором GOSUB, который вызывал данную процедуру.
        Обеспечена вложенность выполнения процедур, количество вложенных
процедур не ограниченно.
        Если заданная Метка в пакете не встречается, выдается сообщение и
выполняется оператор следующий за оператором GOSUB. В случае, если
оператор RETURN встречается без соответствующего опережающего
исполнения оператора GOSUB, выдается сообщение об ошибке и выполнение
пакета продолжается.


        ERRORS:

112 Incorrect label
114 Label not found
115 RETURN without GOSUB
168 Label expected


        GOSUB Write
. . .
Write   . . .
        RETURN



        Оператор GOTO. Безусловный переход.
        -----------------------------------

        GOTO Label

        Оператор GOTO предназначен для безусловной передачи
управления на заданную метку пакета.
        Если заданная Метка в пакете не встречается, выдается сообщение и
выполняется оператор следующий за оператором GOTO.


        ERRORS:

112 Incorrect label
114 Label not found
168 Label expected


        GOTO Label



        Оператор IF. Условный переход.
        ------------------------------

        IF Expression THEN Label

        Оператор IF предназначен для условного перехода в пакете отладки
на заданную метку пакета при выполнении определенного условия в отлаживаемой
программе. Если условие не выполнено, исполнение пакета продолжается дальше
со следующего оператора.
        Если заданная Метка в пакете не встречается, выдается сообщение и
выполняется оператор следующий за оператором IF.


        ERRORS:

128 THEN expected
134 Expression expected
168 Label expected
176 Incorrect expression


        IF Dry.Char1Glob='A' THEN Write
        IF (Str.Len=10)AND(Memory.Limit) THEN exit



        Оператор SIGNAL. Переход по ошибке.
        -----------------------------------

        SIGNAL ( "+" ErrorNumber "," Label ) | ( "-" ErrorNumber )

        Оператор SIGNAL предназначен для перехода в пакете отладки
на заданную метку пакета при возникновении определенной ошибки. Переход
выполняется немедленно после завершения оператора, вызвавшего ошибку. При этом
ошибка считается обработаной и счетчик ошибок не увеличивается. Переход по
ошибке в дальнейшем можно отменить.
        Если заданная Метка в пакете не встречается, выдается сообщение и
выполняется оператор следующий за оператором SIGNAL.
        Используя импорт пакетов и оператор SIGNAL можно раелизовать
собственную обработку произвольной группы ошибок.


        ERRORS:

112 Incorrect label
114 Label not found
168 Label expected
208 Error code expected
209 Incorrect error list action
210 Incorrect error code
211 Handler for error <...> already defined
212 Handler for error <...> not defined


        SIGNAL +700,ErrorLoadProgram
        SIGNAL -700



        Оператор WATCH. Задание отслеживаемых выражений.
        ------------------------------------------------

        WATCH Expression { "," Expression }

        Оператор WATCH обычно предшествует оператору перехода в диалоговый
режим DIALOG и предназначен для задания отслеживаемых выражений в диалоговом
отладчике. При добавлении выражения проверяется его правильность и, в случае
обнаружения некорректности, выдается предупреждение о возможной ошибке
в данном контексте.


        ERRORS:

116 Program not loaded
918 Wrong expression in current context


        WATCH Dry.Char1Glob
        WATCH Dry.Array2Glob[1],Memory.Free<=128



        Оператор DIALOG. Переход в диалоговый режим.
        --------------------------------------------

        DIALOG

        Оператор DIALOG вызывает диалоговый отладчик. После завершения
работы в диалоге, пользователь может вернуться в пакет или закончить отладку.


        ERRORS:

116 Program not loaded


        DIALOG



        Оператор ALIAS. Определение эквивалентного имени.
        -------------------------------------------------

        ALIAS Alias [ "," ( "S," Expression
                          | "L," ModuleName "," LineNumber
                          | "O," OldOperatorName ) ].

        Оператор ALIAS позволяет определить эквивалентное имя.
Эквивилентное имя является синонимом либо символьной строки, либо адреса.
Символьная строка определяется в операторе. Если же указано имя модуля и строка
в нем, то вычисляется адрес, соотвествующий этой строке, в коде
программы.
        Символьное имя на корректность не проверяется, т.к. это будет сделано
при его использовании. При использовании эквивалентного имени в выражении
преполагается, что его можно взять в круглые скобки, и от это результат
вычисления выражения не изменится.
        При переопределении имен операторов старое имя становится недоступным.
При невозможности сопоставить заданую строку модуля коду программы выдается
сообщение об ошибке.


        ERRORS:

116 Program not loaded
126 Incorrect parameter
131 Incorrect address
159 Line number expected
163 Incorrect alias
164 Alias <...> not defined
174 Alias expected
175 Alias definiton expected
189 Alias type expected
213 Module not found
216 Keyword can not be redefined


        ALIAS Alias1,S,Dry.Char1Glog
        ALIAS Alias2,L,Dry,210
        ALIAS Alias3,O,LOAD
        ALIAS Alias1



        Оператор MODULE. Определение текущего модуля.
        ---------------------------------------------

        MODULE [ CurrentModuleName ]

        В отличии от диалогового отладчика, в пакетном не определен текущий
модуль, в следствие чего имена обьектов программы необходимо квалифицировать
именем модуляб что бывает не очень удобно. Оператор MODULE позволяет определить
или отменить текущий модуль. После выполнения этого оператора поиск всех
неквалифицированных имен происходот в заданом (текущем) модуле.


        ERRORS:

116 Program not loaded
213 Module not found


        MODULE Dry
        MODULE



        Операторы управления выполнением отлаживаемой программы.
        ========================================================

        Основным способом управления выполнением отлаживаемой программы
является задание в ней остановов и выполнением некоторых действий в пакете.
Операторы данной функциональной группы позволяют запустить программу и задать
произвольное количество разнообразных остановов.



        Операторы START и STOP.
        --------------------------------------------

        START
        STOP

        Оператор START предназначен для первоначального запуска
тестируемой программы. Для продолжения исполнения пакета после останова
служит оператор STOP. После выполнения этого оператора происходит передача
управления в пакете на оператор, непосредственно следующий за оператором
START, который начал исполнение программы. Операторы START и STOP
образуют пару, подобную паре операторов вызова процедуры
GOSUB и возврата из нее RETURN. Повторный запуск программы
с помощью оператора START невозможен до тех пор, пока не будет
исполнен оператор STOP. В случае, если оператор STOP
встречается не в останове, выдается сообщение об ошибке и выполнение пакета
продолжается.


        ERRORS:

116 Program not loaded
129 Program restart not allowed


        START
        STOP


<<< ADVANCED BEGIN >>>

        Для организации запуска отлаживаемой программы и возврата в пакет
используется стек вызовов процедур. Во время выполнения оператора
START в стек заносится номер строки, непосредственно следующей за
текущей, при этом элемент стека помечается особым признаком, отличающим его от
элементов, помещенных в стек оператором GOSUB. При выполнении оператора
STOP вершиной стека становится помеченный элемент, после чего
номер строки, сохраненный в этом элементе стека, становится номером текущей
строки. Затем из стека удаляется помеченный элемент и выполнение пакета
продолжается дальше.
        Как было отмечено ранее, оператор START не может быть повторно
исполнен до тех пор, пока не будет выполнен оператор STOP. Из этого
следует, что стек вызовов процедур может содержать не более одного помеченного
элемента. Элементы, находящиеся в стеке до помеченного элемента, соответствуют
вызовам процедур, произошедшим до исполнения оператора START. Элементы,
находящиеся в стеке после помеченного элемента, соответствуют вызовам процедур,
произошедшим после исполнения оператора START. Эти элементы будут
удаленны из стека после выполнения оператора STOP. Таким образом,
возврат из процедур, вызов которых произошел после начала выполнения
отлаживаемой программы, становиться невозможным после  ее завершения. Такая
организация взаимодействия операторов вызова и возврата из процедур и
операторов управления выполнением отлаживаемой программы необходима для вызова
внутри каждого варианта выполнения программы процедур, необходимых только для
этого варианта, завершение которых не нужно в случае завершения самого варианта.

<<< ADVACED END >>>




        Оператор RESUME. Продолжение выполнения программы.
        --------------------------------------------------

        RESUME

        Оператор RESUME продолжает исполнение отлаживаемой программы
после точки останова, т.е. с места последнего останова.


        ERRORS:

116 Program not loaded
130 Program was not started


        RESUME



        Оператор BREAK. Задание остановов.
        ----------------------------------

        BREAK Number "," Event "," Label

        Event = StopByUser           |
                ProgramException     |
                ExecutionAddress     |
                AccessWriteInMemory  |
                AccessReadFromMemory |
                BreakByCondition     |
                BreakOnLine.

        StopByUser           = USER.
        ProgramException     = XCPT.
        ExecutionAddress     = ADDR "," Address.
        AccessWriteInMemory  = WRITE "," Address "," Length.
        AccessReadFromMemory = READ "," Address "," Length.
        BreakByCondition     = COND "," BooleanExpression.
        BreakOnLine          = LINE "," ModuleName "," LineNumber.

        Оператор BREAK назначает останов при выполнении отлаживаемой
программы. Каждый останов имеет свой номер, тип и метку в пакете, на которую
необходимо перейти в случае останова. Номер служит для идентификации останова.
Разнообразие типов остановов позволяет прервать исполнение программы в любом
месте, требующем каких-либо дополнительных действий в пакете. Можно задать
останов по достижению заданного адреса в программе, по записи в определенные
переменные и места памяти, по чтению из переменных и памяти, по возникновению
программного прерывания, по обращению к заданным проседурам.Еще один тип
остановов - по заданному условию. В этом случае выполнение продолжается до
момента, когда станет истинным некоторое условие в отлаживаемой программе.
        Определены идентификаторы типов остановов:
 ·  USER  - программа прервана пользователем;
 ·  XCPT  - программное прерывание;
 ·  ADDR  - останов по адресу;
 ·  WRITE - останов по записи;
 ·  READ  - останов по чтению;
 ·  COND  - условный останов;
 ·  LINE  - останов по номеру строки.


        ERRORS:

112 Incorrect label
114 Label not found
116 Program not loaded
131 Incorrect address
151 Incorrect breakpoint number
152 Breakpoint number already in use
153 Incorrect event identifier
155 Incorrect length
159 Line number expected
160 Incorrect line number
161 Break already exists
168 Label expected
169 Breakpoint number expected
170 Breakpoint type expected
171 Breakpoint attributes expected
182 Incorrect break
213 Module not found
917 This break is now set but have disabled state\ndue to hardware limit of access breaks.\nYou can enable it later if place will be free
918 Wrong expression in current context


        BREAK 1,USER,Break
        BREAK 2,XCPT,Break
        BREAK 3,ADDR,Dry.Proc8,Break
        BREAK 4,WRITE,ADR(Dry.Char1Glob),1,Break
        BREAK 5,READ,ADR(Dry.Char1Glob),1,Break
        BREAK 6,COND,Dry.Char1Glob='A',Break
        BREAK 7,LINE,Dry,210,Break



        Оператор DEL.
        -----------------------

        DEL Number { "," Number }

        Оператор DEL исключает остановы с указанными номерами.


        ERRORS:

151 Incorrect breakpoint number
162 Break number <...> not found
169 Breakpoint number expected


        DEL 1
        DEL 3,4,17



        Операторы выдачи и изменения информации.
        ========================================

        Для успешного проведения отладки и тестирования программ необходимо
иметь возможность изменять значения переменных, регистров и областей памяти.
С другой стороны, должна быть также возможность получать значения переменных,
регистров и областей памяти. Для этих целей и служат операторы выдачи и
изменения информации.


        Оператор FILL. Инициализации переменных, регистров.
        ---------------------------------------------------

        FILL ( Address | Register ) "," Length "," WholeExpression

        Оператор FILL предназначен для инициализации переменных,
регистров, областей памяти. Инициализация происходит последовательностью
одинаковых байтов, значение которых заданно в операторе. Как правило, этот
оператор используется перед началом выполнения очередного варианта.
        Левая часть оператора рассматривается как адресное выражение или
регистр. Длина регистра - 4 байта, регистры считаются расположенными один
за другим в пярядке EAX, EBX, ..., EBP, ESP, т.е. так как они отображаются
в диалоговом отладчике слева направо и сверху вниз. Заполнение регистров
происходит с младшего байта. 
        Правая часть оператора - однобайтовая константа. В случае задания
константы, для представления которой необходимо больше 1-го байта,
берется ее младший байт.


        ERRORS:

107 Parameter expected
116 Program not loaded
126 Incorrect parameter
131 Incorrect address
157 Address value expected
203 Write to address <...> failed, len <...>


        FILL ADR(Dry.Char1Glob),1,0x47
        FILL ADR(Dry.Array2Dim),56,0
        FILL &EAX,20,0xFA



        Оператор SET. Задание значений переменным, регистрам.
        -----------------------------------------------------

        SET ( Variable | Register ) "," Expression

        Оператор SET позволяет задавать значения переменным и
регистрам. Одним из параметров этого оператора может быть имя переменной или
регистр. Другим параметром является выражение.
В выражении могут быть использованы
знаки сложения, вычитания, деления и умножения, скобки, целые и действительные
константы, имена переменных, эквивалентных имена, регистры, а также операций
взятия адреса переменной, косвенности, индексации, разыменования. Вычисляется
значение выражения и полученный результат присваивается первому параметру.


        ERRORS:

116 Program not loaded
134 Expression expected
187 Write to register <...> failed
200 Variable or register expected
201 Type incompatibility in assignment
205 Stuctured variable not allowed in this context
!!! ???


        SET Dry.Char1Glob,'A'
        SET &ESP,0xFAFBFCFD



        Оператор MOVE. Пересылка с адреса на адрес.
        -------------------------------------------

        MOVE SourceAddress "," DestinationAddress "," Length

        Оператор MOVE позволяет пересылать заданое количество байт
с одного места в памяти в другое. Источник и приемник определяются адресами,
задаными в операторе.
        В качестве значения адреса приемника или источника используется
значение выражения.
В выражении могут быть использованы знаки сложения, вычитания, деления и
умножения, скобки, целые константы, регистры, а также операций взятия адреса
переменной, косвенности, индексации, разыменования. Тип выражения должен быть
совместим с типом адрес, т.е. результатом выражения может быть целое
число или адрес. Вычисленное значение выражения приводится
к типу адрес.
        Задание пересылаемого количества байт является обязательным. Длина
определяет количество байтов пересылаемой информации.


        ERRORS:

116 Program not loaded
126 Incorrect parameter
155 Incorrect length
157 Address value expected
203 Write to address <...> failed, len <...>


        MOVE ADR(Dry.Char1Glob),ADR(Dry.Array1Dim),1



        Оператор PRINT. Печать сообщений в протокол.
        ------------------------------------------

        PRINT Text { ',' Expression }.

        Text          = '"' Letters | '%' Format | ControlSymbol '"'.
        ControlSymbol = '\' ( 'n', 'r', 'l', 'f', 't', 'e', 'g', '\').
        Format        = { Modificator } Base | MemoryRegion
        Modificator   = '$' | '-' | '+' | '|' | '#' | Space | Width | Precision
        Base          = 'i' | 'd' | 'x' | 'o' | 'b' | 'c' | 's' |
                        'f' | 'e' | 'g' | 'X' | 'F' | 'E  | 'G' | 'u';
        MemoriRegion  = ('M'|'m') "(" "'" Format "'" [',l' Const [',k' Const ] ] ")"
        Width         = Digit { Digit }
        Pricision     = '.' Digit { Digit }

        Оператор PRINT осуществляет вывод в протокол текстовых сообщений
и значений переменных программы. Богатый набор форматов, подобный форматам,
принятым в языке Си, позволяет печатать значения переменных в любом удобном виде.
        После выполнения оператора печати строка переводится.

 - Форматная cтрока содержит описание Форматов. Каждый Формат используется
   только для печати одного Выражения. Количество описаний Форматов, таким
   образом,  должно соответствовать количеству Выражений, записываемых после
   ФорматнойСтроки. При задании Формата, для которого отсутствии Выражение,
   будет выдана ошибка. При задании большего количества Выражений, чем
   требуется для соответствующих Форматов, будет выдано предупреждение.

 - Формат содержит обычный текст, символы управления печатью, а также,
   собственно, сам формат печати Выражения. При печати информация выводится
   в поле печати. Управление печатью осуществляется путем задания
   модификаторов печати. По умолчанию модификаторы отсутствуют,
   ширина поля печати выбирается минимально необходомой для представления
   выводимой информации.

 - Управляющие символы определяют вставку в выводимый текст следующих
   символов (приведены коды и мнемонические названия):
     'n' - 15C+12С, обозначает CR+LF;
     'r' - 15C, обозначает CR;
     'l' - 12C, обозначает LF;
     'f' - 14C, обозначает FF;
     't' - 11C, обозначает TAB;
     'e' - 33C, обозначает ESC;
     'g' - 7C, обозначает BEL;
     '\' - 134C, обозначает '\';
     '%' - 45C, обозначает '%';

 - Формат содержит базу и модификатор печати. Базы предназначены для
   задания определенного типа печати значений:
   'b'           - бинарных, беззнаковых целых;
   'o'           - восьмеричных, беззнаковых целых;
   'u'           - десятичных, беззнаковых целых;
   'i', 'd'      - десятичных, беззнаковых целых;
   'x', 'X'      - беззнаковых целых шеснадцатиричных, с заданием регистра;
   'c'           - символьных;
   's'           - строковых;
   'f', 'F'      - вещественных, фиксированный,  с заданием регистра;
   'e', 'E'      - вещественных, экспоненциальный, с заданием регистра;
   'g', 'G'      - вещественных, с выбором минимального для представления
                   формата, с заданием регистра;
   'w'           - булевских, причем выражения целого типа приводятся к
                   булевскому типу по правилу: если значение выражения равно 0,
                   значение булевского выражения равно FALSE, иначе TRUE.

   Задание различного регистра букв для базы предназначено  для изменения
   регистра выводимых букв (прописные/строчные). Для печати самого
   символа '%', его необходимо повторить дважды.

 - "Область памяти" предназначена для печати областей заданой длины
   по указаному количеству байт в блоке по определенному формату.
   Обозначение - 'M', 'm'. При отсутствии длины блока она принимается
   равной 1, при отсутствии длины области пямяти она принимается равной 1.
   Задаваемый формат применяется для всех блоков, расположенных внутри
   заданной области. При задании некратной длины области и блока, длина
   последнего блока при печати получается меньше заданой.

 - Модификаторы предназначены для управления печатью внутри одной базы.
   Определены следующий модификаторы:
   '$'       - задает дополнение нулями до ширины поля печати;
   '+'       - задает печать знака, независимо от знака числа;
   '-'       - значение пишется слева в поле установленной ширины;
   '|'       - значение пишется центре поля установленной ширины;
   '#'       - показывает число с указанием основания;
   Пробел    - выставляется знак, если число отрицательное, иначе пробел;
   Точность  - задает число значащих цифр после запятой в форматах 'f','e','g'.
   Ширина    - задает общую ширину поля (с учетом возможных символов основания,
               знака и т.п.); если указанной ширины недостаточно для
               представления выводимого значения, происходит автоматическое
               расширение поля до минимально необходимого.


        ERRORS:

134 Expression expected
143 Double quotes expected
144 String not terminated (double quotes expected)
204 Read from address <...> failed, len <...>
205 Stuctured variable not allowed in this context
206 Register is not allowed


        PRINT "Hello, world!"
        PRINT "Char1Glob='%c'",Char1Glob
        PRINT "------\n\t1 bell\g\n\t2 bell\g\n\t3 bell\g\n------"
        PRINT "Array1Glob: [7]=%u, [8]=%u",Array1Glob[7],Array1Glob[8]
        PRINT "Memory region: %M('%$4X\n',k4,l20)",ADR(Array1Glob[6])



        Операторы управления формированием структуры протокола.
        =======================================================

        В процессе работы пакетный отладчик формирует протокол отладки,
содержащий все информационные сообщения. Объем выдаваемой информации может быть
достаточно велик. Данные операторы позволяют задавать направление вывода
протокола и управлять формированием структуры протокола отладки.


        Оператор LOG. Направление вывода протокола.
        -------------------------------------------

        LOG [ FileName [ "." [ FileExt ] ]

        Оператор LOG назначает направления вывода протокола отладки.
Можно задать вывод как на экран, так и в файл. Возможность вывода протокола
отладки в файл позволяет сохранять результаты тестирования программы для
дальнейшего использования и более детального изучения. Сохраненный в файле
протокол отладки также необходим для отслеживания стабильности работы программ
при внесении в них каких-либо изменений.
        Если направление вывода - экран, то вся информация о работе отладчика
отображается на экране, в соответствии с заданными режимами оператора MODE.
        Если протокол отладки формируется в файле, на экране будут отображатся
только сообщения об ошибках и скобки вариантов. При отсутствии указания имени
файла в качестве имени файла протокола будет использованно имя исполняемого
пакета с расширением, принятым по умолчанию для файла протокола.


        ERRORS:

004 Error opening protocol file <...>
117 Incorrect protocol name


        LOG
        LOG result.
        LOG result.dat



        Оператор MODE. Определение структуры протокола отладки.
        -------------------------------------------------------

        MODE ShiftMode ("-"|"+") | ControlMode

        Оператор MODE задает структуру протокола отладки. С помощью
этого оператора можно разрешить или запретить вывод отдельных видов информации:
отображение выполняющихся операторов языка отладки; отображение выполняющихся
команд отлаживаемой программы; выполнение оператора PRINT.
   · PAK    - задает отображение выполняющихся операторов языка отладки.
   · TRACE  - задает отображение выполняющихся команд отлаживаемой программы.
              Для выбора режима отображения используются модификаторы:
              CODE   - режим дизассемблера.
              SOURCE - режим исходного текста.
              MIX    - смешанный режим.
   · DUMP   - разрешает отображение дампа выполняемой команды.
   · DISASM - управляет режимами работы дизассемблера.
              Для выбора режима работы дизассемблера используются модификаторы:
              SMALL - минимальный.
              FULL  - полный.
   · PRINT  - разрешает выполнение оператора PRINT ( выдачу в протокол ).
   · ADDR   - задает отображение адреса группы байт при печати областей памяти.
   · ERRORS - управление числом выдаваемых сообщений об ошибках. При достижении
              количества сообщений об ошибках, заданных константой в режиме
              ERRORS, работа отладчика завершается. При некорректном задании:
              - если Константа < 1, то ERRORS не изменяется;
              - если Константа > MAX(ERRORS), то ERRORS = MAX(ERRORS).
              ERRORS по-умолчанию установлен равным 20, MAX(ERRORS) по-умолчанию
              установлен равным 100.
   · Режимы управления отображением информации, связанной с остановами,
     совпадает с соответствующими идентификаторами типов остановов:
              USER  - программа прервана пользователем;
              XCPT  - программное прерывание;
              ADDR  - останов по адресу;
              WRITE - останов по записи;
              READ  - останов по чтению;
              COND  - условный останов;
              LINE  - останов по номеру строки.


        ERRORS:

126 Incorrect parameter
137 Incorrect mode
138 Errors limit set to <...>
172 Mode expected


         MODE TRACE-
         MODE TRACE+,CODE,DUMP+,DISASM=FULL
         MODE PRINT+,ADDR-
         MODE ERRORS=10




        Список ошибок, выдаваемых пакетным отладчиком.
        ==============================================

004 Error opening protocol file <...>
007 Batch name missed.
009 Too many nested packages (16)
010 Package <...> recursively imported
011 Incorrect package name <...>
014 Imported package <...> not found.
018 Unknown directive <...>.
107 Parameter expected
111 Label '<...>' already defined
112 Incorrect label
113 Label matches reserved word
114 Label not found
115 RETURN without GOSUB
116 Program not loaded
117 Incorrect protocol name
126 Incorrect parameter
127 Incorrect program name
128 THEN expected
129 Program restart not allowed
130 Program was not started
131 Incorrect address
134 Expression expected
137 Incorrect mode
138 Errors limit set to <...>
143 Double quotes expected
144 String not terminated (double quotes expected)
151 Incorrect breakpoint number
152 Breakpoint number already in use
153 Incorrect event identifier
155 Incorrect length
157 Address value expected
159 Line number expected
160 Incorrect line number
161 Break already exists
162 Break number <...> not found
163 Incorrect alias
164 Alias <...> not defined
165 Program name expected
168 Label expected
169 Breakpoint number expected
170 Breakpoint type expected
171 Breakpoint attributes expected
172 Mode expected
174 Alias expected
175 Alias definiton expected
176 Incorrect expression
182 Incorrect break
187 Write to register <...> failed
189 Alias type expected
200 Variable or register expected
201 Type incompatibility in assignment
203 Write to address <...> failed, len <...>
204 Read from address <...> failed, len <...>
205 Stuctured variable not allowed in this context
206 Register is not allowed
208 Error code expected
209 Incorrect error list action
210 Incorrect error code
211 Handler for error <...> already defined
212 Handler for error <...> not defined
213 Module not found
216 Keyword can not be redefined
700 Loading <...>: <...>
917 This break is now set but have disabled state\ndue to hardware limit of access breaks.\nYou can enable it later if place will be free
918 Wrong expression in current context





        Правила обработки имен файлов.
        ==============================

        Если в пакете отладки используется имя файла, то отладчик при
исполнении этого пакета поступает следующим образом:
- проверяет синтаксическую правильность заданного имени файла;
- при указании имени с расширением или имени с точкой на конце, т.е. полного
  имени или имени без расширения, указанное имя используется в качестве имени
  файла без изменений;
- если указанно только имя без точки на конце, то к имени файла добавляется
  стандартное расширение, принятое в данном контексте.
        По умолчанию принято расширение имени файла:
   · 'RED' - для redirection-файле системы;
   · 'MSG' - для файла, содержащего сообщения отладчика;
   · 'HLP' - для файла помощи и справок,
   · 'XD'  - для пакетов отладки;
   · 'XD'  - для импортируемых пакетов;
   · 'RES' - для файлов протокола;
   · 'EXE' - для исполняемой программы;
   · 'MOD' - для исходных текстов модулей;

        Для создания файла с протоколом отладки по умолчанию принято имя файла
'PROTOCOL.RES'. Оно используется также при возникновении каких-либо ошибок при
записи протокола отладка - в этом случае отладчик пытается создать протокол
с умолчательным именем.
        Отладчик выполняет поиск фалов в соответствии с указанными списками
путей поиска, содержащихся в redirection-файле системы.





        Протокол отладки. Сообщения пакетного отладчика.
        ================================================

    Протокол отладки состоит из следующих частей:

- Сообщения об исполняемом пакете;
- Трасса пакета;
- Трасса выполнения отлаживаемой программы;
- Результаты выполнения операторов (PRINT, др.);
- Информационные сообщения отладчика (остановы, др.);
- Сообщения отладчика об ошибках.

    Для управления формированием протокола отладки можно использовать
оператор MODE. Способы задания режимов формирования протокола даны при
описании оператора MODE.
    Определить имя протокола отладки можно с помощью оператора LOG.



                1. Сообщения об исполняемом пакете.

    При загрузке пакета отладчик выдает сообщение:

Package <BatchName> is being executed.


    При исполнении команды импорта отладчик выдает сообщение:

IMPORT (<ИмпортирующийПакет>,<НомерСтроки>,<Позиция>): <ИмпортируемыйПакет>.
<ИмпортирующийПакет> - импортирующий пакет;
<ИмпортируемыйПакет> - импортируемый пакет;
<НомерСтроки>        - номер испольненяемой  строки;
<Позиция>            - позиция в строке.


    Если при выполнении перехода по метке происходит смена пакета, т.е.
происходит переход по метке, принадлежащей проимпортированному пакету,
отладчик выдает об этом следующее информационное сообщение:

Part │ <BatchName>.


    При выполнении переходов по меткам в пределах одного пакета никаках
специальных сообщений об этом отладчик не выдает.
    По окончании работы отладчик выдает сообщения:

- если отладка завершена нормально (выполнен оператор QUIT или выполнена
  последняя строка пакета):

Package <BatchName> execution finished.


- если отладка прервана по какой-либо причине (пользователем, при возникновении
определенного сорта событий в программе, др.):

Address <Address>: <Причина останова>.



        1.2. Пример.

Package TEST.XD is being executed
Part │ TEST.XD.
    1│          LOAD dry
    2│          START
Address 77F2AA2C: Exception 40010005 at 77F2AA2C.
    3│
Package TEST.XD execution finished.



                2. Трасса пакета.

    Трасса пакета - это трасса выполняющихся операторов пакета.
Выполняющийся оператор в трассе предваряется номером строки в пакете,
затем следует строка из пакета с этим оператором без каких-либо изменений:

<Номер_строки_пакета>│ <Строка_пакета_с_оператором>

        2.2. Пример.

    1│          LOG
    2│          LOAD dry
    3│          BREAK 1,ADDR,Dry.Proc8,Dialog
    4│          BREAK 2,XCPRT,Error
    5│          MODE TRACE+
    6│          START



                3. Трасса выполнения отлаживаемой программы.

    Трасса выполнения отлаживаемой программы - это отображение
всех выполняющихся операторов отлаживаемой программы.

     │<Текущий_адрес_в_отлаживаемой_программы> <Команда_отлаживаемой_программы>


        3.2. Пример.

     │  BEGIN
     │  004012F0 push     ebp
     │  004012F1 mov      ebp, esp
     │  004012F3 push     ebx
     │  004012F4 push     esi
     │  004012F5 push     edi
     │  004012F6 add      esp, -96
     │          InOut.WriteString ("Please, wait about 60 seconds");
     │  004012F9 push     30
     │  004012FB push     4219056
     │  00401300 call     InOut_WriteString
     │          InOut.WriteLn;
     │  00401305 call     InOut_WriteLn
     │          time (starttime);
     │  0040130A lea      eax, ebp-32
     │  0040130D push     eax
     │  0040130E call     dry.time
     │          time (benchtime);
     │  00401313 lea      ecx, ebp-40
     │  00401316 push     ecx
     │  00401317 call     dry.time
     │          nulltime := benchtime - starttime;
     │  0040131C mov      eax, [ebp-40]




            4. Результаты выполнения операторов (PRINT, др.).

        4.1. Формат сообщений оператора PRINT определяется самим оператором.





                5. Информационные сообщения отладчика (остановы, др.).

        5.1. Формат сообщений об произошедшем останове.

    При возникновении останова, заданного оператором BREAK,
отладчик выдает одно из сообщений, в зависимости от вида останова.
Сообщение содержит номер случившегося останова и причина, приведшая к останову.


        5.1.2. Пример.

Break #7, address 00401398: Breakpoint.
Break #4, address 0040128A: Write in [0040700C..0040700C] by address 0040700C,
          block length 1; old value 000H, new value 041H.
Break #5, address 0040128A: Read/Write memory access, address 0040700C,
          block len = 1; read value 0x41.
Break #2, address 77F2AA2C: Exception 40010005 at 77F2AA2C.
Break #3, address 00404F4F: Program finished.




               6. Сообщения отладчика об ошибках.

    Во время работы для поиска требуемых файлов отладчик использует
redirection-файл, содержащий списки путей для поиска файлов, удовлетворяющих
заданым шаблонам. При его отсутствии выдается сообщение:

Redirection-файл XD.RED не найден.

    Текст сообщений должен находится в файле 'DVX.MSG'. Отладчик осуществляет
поиск файла сообщений в соответствии с redirection-файлом, при отсутствии
такового или если список путей для файла сообщений не задан, поиск продолжается
сначала в текущем, а затем в "домашнем" каталоге . Если отладчик и в этом
случае не находит файла сообщений, то он прекращает работу с выдачей сообщения:

Файл XD.MSG не найден.

    Сообшения об ошибках во время работы выдаются отладчиком
в следующей форме на отдельной строке:

Ошибка (<ИмяПакета>, <НомерСтроки>, <Позиция>): <Сообщение>.
<НомерСтроки> - номер строки, при испольнении которой произошла ошибка;
<Позиция> - позиция в строке;
<Сообщение> - краткое описание причины возникшей ошибки.

    Во время работы отладчик также может выдавать сообщения предупреждающего
характера в следующей форме на отдельной строке:

Предупреждение (<ИмяПакета>, <НомерСтроки>, <Позиция>): <Сообщение>.
<НомерСтроки>  - номер строки;
<Позиция> - позиция в строке;
<Сообщение> - краткое описание причины предупреждения.

    Указатель позиции в строке находиться обычно после параметра оператора,
вызвавшего ошибку или там, где предположительно должен быть ожидаемый параметер.
    При превышении определенного количества ошибок отладчик прекращает работу.
Задать максимальное количество ошибок, после которого отладчик прекращает
работу, можно с помощью оператора РЕЖИМ/LIST. По умолчанию установленное
значение равно 20. Ограничений на количество выдаваемых предупреждений нет.
    Если во время работы были обнаружены ошибки или выданы предупреждения,
отладчик информирует об этом перед завершение работы, указывая отдельно
количество ошибок и предупреждений:

Всего ошибок <КоличествоОшибок>, предупреждений <КоличествоПредупреждений>.


        6.1.2. Пример.

Error (T01.XD,13,1): Program not loaded.
Warning (T01.XD,15,20): Label not found.
Total errors 1, warnings 5.



                7. Создание протокола. Рекомендации пользовалелю.

    Определить имя протокола отладки можно с помощью оператора LOG.
    При создании протокола отладчик применяет стандартные правила работы
с именами файлов, а также использует перенаправляющий файл системы, если
он есть. Если при попытке создать протокол с заданым именем будет обнаружена
ошибка, отладчик выдаст о ней сообщение, а затем попытается создать
протокол с именем, принятым по умолчанию, - 'PROTOCOL.RES'. Если эта попытка
создания протокола также окажется неудачной, отладчик попытается создать
протокол отладки в текущей директории, игнорируя redirection-файл системы.
Если и эта мера не приведет к успешному созданию протокола, отладчик, выдав
сообщение о невозможности создания умолчательного протокола, перейдет в
режим выдачи протокола на экран.
    Задать указание отладчику создавать протокол по умолчанию можно путем
использования параметра 'R' в командной строке при запуске отладчика.
(См. "Использование, опции и параметры запуска программы.")
    Отладчик позволяет задать режим работы с закрытым протоколом отладки.
Этот режим несколько замедляет работу отладчика, но зато является более
надежным - позволяет сохранить протокол при самых неблагоприятных
обстоятельствах. Задать указание отладчику перейти в этот режим можно путем
использования параметра 'S' в командной строке при запуске отладчика.
(См. "Использование, опции и параметры запуска программы.")

